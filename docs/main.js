(()=>{"use strict";var t={126:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t){if(16!==(t=t||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]).length)throw new Error("Matrix is 4x4");this.data=new Float32Array(t)}multiply(t){const e=this.data[0],i=this.data[1],r=this.data[2],n=this.data[3],s=this.data[4],o=this.data[5],a=this.data[6],h=this.data[7],l=this.data[8],c=this.data[9],u=this.data[10],d=this.data[11],f=this.data[12],g=this.data[13],m=this.data[14],p=this.data[15],_=t.data[0],w=t.data[1],E=t.data[2],v=t.data[3],T=t.data[4],x=t.data[5],P=t.data[6],y=t.data[7],L=t.data[8],I=t.data[9],M=t.data[10],S=t.data[11],R=t.data[12],A=t.data[13],B=t.data[14],O=t.data[15];this.data[0]=_*e+w*s+E*l+v*f,this.data[1]=_*i+w*o+E*c+v*g,this.data[2]=_*r+w*a+E*u+v*m,this.data[3]=_*n+w*h+E*d+v*p,this.data[4]=T*e+x*s+P*l+y*f,this.data[5]=T*i+x*o+P*c+y*g,this.data[6]=T*r+x*a+P*u+y*m,this.data[7]=T*n+x*h+P*d+y*p,this.data[8]=L*e+I*s+M*l+S*f,this.data[9]=L*i+I*o+M*c+S*g,this.data[10]=L*r+I*a+M*u+S*m,this.data[11]=L*n+I*h+M*d+S*p,this.data[12]=R*e+A*s+B*l+O*f,this.data[13]=R*i+A*o+B*c+O*g,this.data[14]=R*r+A*a+B*u+O*m,this.data[15]=R*n+A*h+B*d+O*p}static Ortho(t,e,r,n,s,o){return new i([2/(e-t),0,0,0,0,2/(n-r),0,0,0,0,2/(s-o),0,(t+e)/(t-e),(r+n)/(r-n),(s+o)/(s-o),1])}static Perspective(t,e,r,n){const s=Math.tan(.5*Math.PI-.5*t),o=1/(r-n);return new i([s/e,0,0,0,0,s,0,0,0,0,(r+n)*o,-1,0,0,r*n*o*2,0])}static Translate(t,e,r){return new i([1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1])}static XRotate(t){const e=Math.cos(t),r=Math.sin(t);return new i([1,0,0,0,0,e,r,0,0,-r,e,0,0,0,0,1])}static YRotate(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,0,-r,0,0,1,0,0,r,0,e,0,0,0,0,1])}static ZRotate(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,r,0,0,-r,e,0,0,0,0,1,0,0,0,0,1])}static Scale(t,e,r){return new i([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}static LookAt(t,e,r,n,s,o,a,h,l){let c=n-t,u=s-e,d=o-r;const f=1/Math.sqrt(c*c+u*u+d*d);c*=f,u*=f,d*=f;let g=u*l-d*h,m=d*a-c*l,p=c*h-u*a;const _=1/Math.sqrt(g*g+m*m+p*p);return g*=_,m*=_,p*=_,new i([g,m*d-p*u,-c,0,m,p*c-g*d,-u,0,p,g*u-m*c,-d,0,0,0,0,1]).translate(-t,-e,-r)}translate(t,e,r){return this.multiply(i.Translate(t,e,r)),this}xRotate(t){return this.multiply(i.XRotate(t)),this}yRotate(t){return this.multiply(i.YRotate(t)),this}zRotate(t){return this.multiply(i.ZRotate(t)),this}scale(t,e,r){return this.multiply(i.Scale(t,e,r)),this}lookAt(t,e,r,n,s,o,a,h,l){return this.multiply(i.LookAt(t,e,r,n,s,o,a,h,l)),this}}e.default=i},109:(t,e)=>{function i(t,e,i,r){for(let n=0;n<t.positions.length;n+=3)t.positions[n+0]+=e,t.positions[n+1]+=i,t.positions[n+2]+=r}var r;Object.defineProperty(e,"__esModule",{value:!0}),e.Pyramid=e.Triangle=e.Plane45deg=e.PlaneRotate=e.YZPlane=e.XZPlane=e.XYPlane=e.Cuboid=e.rotateZ180=e.translate=void 0,e.translate=i,e.rotateZ180=function(t){let e=-1e5,r=-1e5;for(let i=0;i<t.positions.length;i+=3){const n=t.positions[i+0],s=t.positions[i+1];e=Math.max(n,e),r=Math.max(s,r),t.positions[i+0]=-n,t.positions[i+1]=-s,3===t.normals.length?0===i&&(t.normals[0]*=-1,t.normals[1]*=-1):(t.normals[i+0]*=-1,t.normals[i+1]*=-1)}i(t,e,r,0)},e.Cuboid=function(t,e,i){return{positions:[0,0,0,t,0,0,t,0,i,0,0,i,t,0,0,t,0,i,t,e,0,t,e,i,0,e,0,t,e,0,t,e,i,0,e,i,0,0,0,0,0,i,0,e,0,0,e,i,0,0,i,t,0,i,t,e,i,0,e,i,0,0,0,t,0,0,t,e,0,0,e,0],normals:[0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1],indexes:[0,1,2,0,2,3,4,6,5,5,6,7,8,10,9,8,11,10,12,13,14,13,15,14,16,17,18,16,18,19,20,22,21,20,23,22]}},e.XYPlane=function(t,e){return{positions:[0,0,0,t,0,0,0,e,0,t,e,0],normals:[0,0,1],indexes:[0,1,2,2,1,3]}},e.XZPlane=function(t,e){return{positions:[0,0,0,t,0,0,0,0,e,t,0,e],normals:[0,-1,0],indexes:[0,1,2,2,1,3]}},e.YZPlane=function(t,e){return{positions:[0,0,0,0,0,e,0,t,0,0,t,e],normals:[-1,0,0],indexes:[0,1,2,2,1,3]}},function(t){t[t.X=0]="X",t[t.Y=1]="Y"}(r=e.PlaneRotate||(e.PlaneRotate={})),e.Plane45deg=function(t,e,i,n,s){const o=n?0:i,a=s===r.Y?n?i:0:o,h=s===r.Y?o:n?i:0,l=.7071;return{positions:[0,0,o,t,0,a,0,e,h,t,e,s===r.Y?a:h],normals:[s===r.Y?l:0,s===r.Y?0:l,l],indexes:[0,1,2,2,1,3]}},e.Triangle=function(t,e,i,r,n,s,o,a,h){return{positions:[0,0,0,t,e,i,r,n,s],normals:[o,a,h],indexes:[0,1,2]}},e.Pyramid=function(t,e,i){const r=Math.atan(i/(t/2))+Math.PI/2,n=Math.cos(r),s=Math.sin(r),o=Math.atan(i/(e/2))+Math.PI/2,a=Math.cos(o),h=Math.sin(o);return{positions:[0,0,0,t,0,0,0,e,0,t,e,0,0,0,0,t/2,e/2,i,0,e,0,t,0,0,t,e,0,t/2,e/2,i,0,0,0,t,0,0,t/2,e/2,i,0,e,0,t/2,e/2,i,t,e,0],normals:[0,0,-1,0,0,-1,0,0,-1,0,0,-1,n,0,s,n,0,s,n,0,s,-n,0,s,-n,0,s,-n,0,s,0,a,h,0,a,h,0,a,h,0,-a,h,0,-a,h,0,-a,h],indexes:[0,1,2,2,1,3,4,5,6,7,8,9,10,11,12,13,14,15]}}},921:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0});const r=i(300);e.default=class{constructor(t,e,i,n,s){if(this.attrs=new Map,this.uniforms=new Map,this.gl=t.getContext("webgl")||t.getContext("experimental-webgl"),!this.gl)throw new Error("WebGL is not supported!");if(this.instancedExt=this.gl.getExtension("ANGLE_instanced_arrays"),!this.instancedExt)throw new Error("WebGL ANGLE_instanced_arrays extension is not supported!");this.prog=(0,r.createProgramFromScripts)(this.gl,e,i),n.forEach((t=>this.attrs.set(t,this.gl.getAttribLocation(this.prog,t)))),s.forEach((t=>this.uniforms.set(t,this.gl.getUniformLocation(this.prog,t))))}useProgram(){this.gl.useProgram(this.prog)}uniformMatrix(t,e){const i=this.getUniformLoc(t),r=e.length;if(4===r)this.gl.uniformMatrix2fv(i,!1,e);else if(9===r)this.gl.uniformMatrix3fv(i,!1,e);else{if(16!==r)throw new Error(`Matrix size ${r} is not supported`);this.gl.uniformMatrix4fv(i,!1,e)}}uniformVector(t,e,i,r,n){const s=this.getUniformLoc(t);void 0!==n?this.gl.uniform4f(s,e,i,r,n):void 0!==r?this.gl.uniform3f(s,e,i,r):void 0!==i?this.gl.uniform2f(s,e,i):this.gl.uniform1f(s,e)}textureFromImg(t,e,i,r,n,s,o){const a=this.getUniformLoc(t);this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texImage2D(this.gl.TEXTURE_2D,0,i,i,n,r),(!0===o||o.generate)&&this.gl.generateMipmap(this.gl.TEXTURE_2D),!0!==o&&(this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,o.wrapS),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,o.wrapT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,o.minFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,o.magFilter)),this.gl.uniform1i(a,s),this.gl.activeTexture(this.gl.TEXTURE0+s)}textureFromBuf(t,e,i,r,n,s,o,a,h){const l=this.getUniformLoc(t);this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texImage2D(this.gl.TEXTURE_2D,0,i,n,s,0,i,o,r),(!0===h||h.generate)&&this.gl.generateMipmap(this.gl.TEXTURE_2D),!0!==h&&(this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,h.wrapS),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,h.wrapT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,h.minFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,h.magFilter)),this.gl.uniform1i(l,a),this.gl.activeTexture(this.gl.TEXTURE0+a)}arrayBuffer(t,e,i,r,n=!1){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,t),void 0!==r&&this.gl.bufferData(this.gl.ARRAY_BUFFER,r,n?this.gl.DYNAMIC_DRAW:this.gl.STATIC_DRAW),Object.entries(i).forEach((([t,i])=>{const r=this.getAttrLoc(t);this.gl.enableVertexAttribArray(r),this.gl.vertexAttribPointer(r,i.elems,i.elType,i.normalized,e,i.offsetBytes)}))}indexBuffer(t,e,i=!1){this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t),void 0!==e&&this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,e,i?this.gl.DYNAMIC_DRAW:this.gl.STATIC_DRAW)}drawElements(t,e,i,r=0){this.gl.drawElements(t,e,i,r)}drawArrays(t,e,i=0){this.gl.drawArrays(t,i,e)}markAttributeInstanced(t,e=1){const i=this.getAttrLoc(t);this.instancedExt.vertexAttribDivisorANGLE(i,e)}drawArraysInstanced(t,e,i,r=0){this.instancedExt.drawArraysInstancedANGLE(t,r,e,i)}createBuffer(){return this.gl.createBuffer()}deleteBuffer(t){this.gl.deleteBuffer(t)}createTexture(){return this.gl.createTexture()}destroyProgram(){this.gl.deleteProgram(this.prog)}get width(){return this.gl.canvas.clientWidth}get height(){return this.gl.canvas.clientHeight}getAttrLoc(t){const e=this.attrs.get(t);if(void 0===e)throw new Error(`Program has no ${t} attribute variables`);return e}getUniformLoc(t){const e=this.uniforms.get(t);if(void 0===e)throw new Error(`Program has no ${t} uniform variables`);return e}}},300:(t,e)=>{function i(t,e,i){const n=t.createShader(e);if(n){if(t.shaderSource(n,i),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS))return n;console.error(t.getShaderInfoLog(n)),r(t,n)}throw new Error("Shader couldn't be compiled")}function r(t,e){t.deleteShader(e)}function n(t,e,i){const r=t.createProgram();if(r){if(t.attachShader(r,e),t.attachShader(r,i),t.linkProgram(r),t.getProgramParameter(r,t.LINK_STATUS))return r;console.error(t.getProgramInfoLog(r)),s(t,r)}throw new Error("Program couldn't be created")}function s(t,e){t.deleteProgram(e)}Object.defineProperty(e,"__esModule",{value:!0}),e.isVisible=e.resizeContext=e.deleteProgram=e.createProgramFromScripts=e.createProgram=e.deleteShader=e.createShader=void 0,e.createShader=i,e.deleteShader=r,e.createProgram=n,e.createProgramFromScripts=function(t,e,r){return n(t,i(t,t.VERTEX_SHADER,e),i(t,t.FRAGMENT_SHADER,r))},e.deleteProgram=s,e.resizeContext=function(t){const e=t.canvas,i=window.devicePixelRatio,r=Math.round(e.clientWidth*i),n=Math.round(e.clientHeight*i);e.width==r&&e.height==n||(e.width=r,e.height=n,t.viewport(0,0,r,n))},e.isVisible=function(t){const e=t.canvas.getBoundingClientRect(),i=e.top,r=e.bottom,n=window.innerHeight;return r>0&&i<n}},674:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseMTL=void 0,e.parseMTL=function(t){const e=new Map;let i={};const r={newmtl(t,r){i={},e.set(r,i)},Ns(t){i.shininess=parseFloat(t[0])},Ka(t){i.ambient=t.map(parseFloat)},Kd(t){i.diffuse=t.map(parseFloat)},Ks(t){i.specular=t.map(parseFloat)},Ke(t){i.emissive=t.map(parseFloat)},Ni(t){i.opticalDensity=parseFloat(t[0])},d(t){i.opacity=parseFloat(t[0])},illum(t){i.illum=parseInt(t[0])}},n=/(\w+)\s+(.*)/;for(const e of t.split("\n").map((t=>t.trim()))){if(""===e||e.startsWith("#"))continue;const t=n.exec(e);if(!t)continue;const[,i,s]=t,o=e.split(/\s+/).slice(1),a=r[i];a?a(o,s):console.debug("unhandled keyword:",i)}return e}},391:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(){this.positions=[[0,0,0]],this.texcoords=[[0,0]],this.normals=[[0,0,0]],this.geometries=[]}static parse(t){const e=new i;let r=null;function n(){if(r&&r.triangles.length){if(!r.name&&e.geometries.length>1){const t=e.geometries[e.geometries.length-2];r.name=t.name}r=null}}function s(){if(null===r){const t={triangles:[]};e.geometries.push(t),r=t}return r}function o(t){const e=t.split("/");if(2===e.length&&e.push("0"),3!==e.length)throw new Error(`Expected 3 vertex indexes like '1/1/1'. Found ${e.length} indexes: ${t}`);const i=e.map((t=>parseInt(t)));if(i.some((t=>isNaN(t))))throw new Error(`Vertex indexes '${t}' is not supported`);return i}const a={v(t){if(3!==t.length)throw new Error(`'v' command has ${t.length} coordinates. Expected 3`);e.positions.push(t.map((t=>parseFloat(t))))},vn(t){if(3!==t.length)throw new Error(`'vn' command has ${t.length} coordinates. Expected 3`);e.normals.push(t.map((t=>parseFloat(t))))},vt(t){if(t.length<2)throw new Error(`'vt' command has ${t.length} coordinates. Expected at least 2`);e.texcoords.push(t.map((t=>parseFloat(t))).slice(0,2))},f(t){const e=s(),i=t.length-2;for(let r=0;r<i;++r)e.triangles.push([o(t[0]),o(t[r+1]),o(t[r+2])])},s(){},mtllib(){},usemtl(t,e){n(),s().material=e},g(){n()},o(t,e){n(),s().name=e}},h=/(\w+)\s+(.*)/;for(const e of t.split("\n").map((t=>t.trim()))){if(""===e||e.startsWith("#"))continue;const t=h.exec(e);if(!t)continue;const[,i,r]=t,n=e.split(/\s+/).slice(1),s=a[i];s?s(n,r):console.debug("unhandled keyword:",i)}return e.geometries=e.geometries.filter((t=>t.triangles.length>0)),e}getPositionOf(t){return this.positions[t[0]]}getNormalOf(t){return this.normals[t[2]]}getSize(){const t={min:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],max:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY]};for(const e of this.geometries)for(const i of e.triangles)for(const e of i){const i=this.getPositionOf(e);for(let e=0;e<3;++e)t.min[e]=Math.min(i[e],t.min[e]),t.max[e]=Math.max(i[e],t.max[e])}return t}getTriangleCount(){return this.geometries.reduce(((t,e)=>t+e.triangles.length),0)}}e.default=i},730:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=class{constructor(t){this.buf=new ArrayBuffer(t),this.view=new DataView(this.buf,0,t),this.size=0}clean(){this.size=0}reserveAndClean(t){t>this.buf.byteLength&&(this.buf=new ArrayBuffer(t),this.view=new DataView(this.buf,0,t)),this.clean()}get rawBuffer(){return this.buf}get bytes(){return this.size}slice(t,e,i){return e=e||0,i=i||Math.trunc((this.size-e)/t.BYTES_PER_ELEMENT),new t(this.buf,e,i)}}},146:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(i(730));class s extends n.default{constructor(t){super(t)}sliceFloat32(t,e){return this.slice(Float32Array,t,e)}sliceUint16(t,e){return this.slice(Uint16Array,t,e)}write4Uint8(t,e,i,r){this.view.setUint8(this.size,t),this.size+=1,this.view.setUint8(this.size,e),this.size+=1,this.view.setUint8(this.size,i),this.size+=1,this.view.setUint8(this.size,r),this.size+=1}write3Float32(t,e,i){this.view.setFloat32(this.size,t,!0),this.size+=4,this.view.setFloat32(this.size,e,!0),this.size+=4,this.view.setFloat32(this.size,i,!0),this.size+=4}write2Float32(t,e){this.view.setFloat32(this.size,t,!0),this.size+=4,this.view.setFloat32(this.size,e,!0),this.size+=4}write1Uint8(t){this.view.setUint8(this.size,t),this.size+=1}write2Uint8(t,e){this.view.setUint8(this.size,t),this.size+=1,this.view.setUint8(this.size,e),this.size+=1}write2Uint16(t,e){this.view.setUint16(this.size,t,!0),this.size+=2,this.view.setUint16(this.size,e,!0),this.size+=2}}e.default=s},333:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(i(730));class s extends n.default{constructor(t){super(t),this.lastIndex=-1}clean(){super.clean(),this.lastIndex=-1}sliceUint8(t,e){return this.slice(Uint8Array,t,e)}sliceUint16(t,e){return this.slice(Uint16Array,t,e)}write3Uint8(t,e,i){this.view.setUint8(this.size,t),this.size+=1,this.view.setUint8(this.size,e),this.size+=1,this.view.setUint8(this.size,i),this.size+=1,this.lastIndex=Math.max(this.lastIndex,t,e,i)}write3Uint16(t,e,i){this.view.setUint16(this.size,t,!0),this.size+=2,this.view.setUint16(this.size,e,!0),this.size+=2,this.view.setUint16(this.size,i,!0),this.size+=2,this.lastIndex=Math.max(this.lastIndex,t,e,i)}write2Uint16(t,e){this.view.setUint16(this.size,t,!0),this.size+=2,this.view.setUint16(this.size,e,!0),this.size+=2,this.lastIndex=Math.max(this.lastIndex,t,e)}write1Uint16(t){this.view.setUint16(this.size,t,!0),this.size+=2,this.lastIndex=Math.max(this.lastIndex,t)}get nextIndex(){return this.lastIndex+1}}e.default=s},607:function(t,e,i){var r=this&&this.__createBinding||(Object.create?function(t,e,i,r){void 0===r&&(r=i),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[i]}})}:function(t,e,i,r){void 0===r&&(r=i),t[r]=e[i]}),n=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),s=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var i in t)"default"!==i&&Object.prototype.hasOwnProperty.call(t,i)&&r(e,t,i);return n(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=o(i(522)),h=o(i(403)),l=o(i(770)),c=i(325),u=i(137),d=s(i(442)),f=s(i(447)),g=o(i(78)),m=o(i(19)),p=i(464);!function(){const t=document.getElementById("particles").querySelector("canvas"),e=()=>{t.width=window.innerWidth,t.height=window.innerHeight};e(),window.addEventListener("resize",e),new a.default(t,400,new h.default("public/mask.png"))}(),function(){const t=document.getElementById("town"),e=t.querySelector("canvas"),i=t.querySelector("button"),r=e=>{const i=t.querySelector(`input[name=${e}]`),r=t.querySelector(`input[name=${e}] ~ span`),n=()=>r.innerHTML=i.value;return n(),i.addEventListener("input",n),()=>parseInt(i.value)},n={width:r("width"),depth:r("depth"),height:r("height"),roads:r("roads"),population:r("population"),vegetation:r("vegetation")},s=()=>{e.width=window.innerWidth,e.height=window.innerHeight};s(),window.addEventListener("resize",s);let o=null;const a=()=>{null==o||o.detach(),o=new l.default(e,new c.Color(.7,.64,.62,1),n.width(),n.height(),n.depth(),n.roads(),n.population(),n.vegetation())};a(),i.addEventListener("click",a)}(),function(){const t="landscape";document.getElementById(t).querySelector("button").addEventListener("click",(()=>{switch((0,u.getState)(t)){case u.State.DAY:(0,u.setState)(t,u.State.NIGHT);break;case u.State.NIGHT:(0,u.setState)(t,u.State.DAY)}}))}(),function(){const t={mill:[{name:"",handler:new Map([["Mill",d.ProgType.POINTS],["propeller",d.ProgType.POINTS]])},{name:"Утвердить требования",handler:new Map([["Mill",d.ProgType.LINES],["propeller",d.ProgType.LINES]])},{name:"Разработать прототип",handler:new Map([["Mill",d.ProgType.SIMPLE_LIGHT],["propeller",d.ProgType.LINES]])},{name:"Разработать рабочий прототип",handler:new Map([["Mill",d.ProgType.SIMPLE_LIGHT],["propeller",d.ProgType.SIMPLE_LIGHT]])},{name:"Рефакторинг",handler:new Map([["Mill",d.ProgType.SPECULAR_LIGHT],["propeller",d.ProgType.SPECULAR_LIGHT]])}],grass:[{name:"Прояснить требования",handler:new Map([["Green_platform",d.ProgType.POINTS],["Island",d.ProgType.POINTS]])},{name:"Утвердить требования",handler:new Map([["Green_platform",d.ProgType.LINES],["Island",d.ProgType.LINES]])},{name:"Насыпать землю",handler:new Map([["Green_platform",d.ProgType.LINES],["Island",d.ProgType.SIMPLE_LIGHT]])},{name:"Посадить газон",handler:new Map([["Green_platform",d.ProgType.SIMPLE_LIGHT],["Island",d.ProgType.SIMPLE_LIGHT]])},{name:"Рефакторинг",handler:new Map([["Green_platform",d.ProgType.SPECULAR_LIGHT],["Island",d.ProgType.SPECULAR_LIGHT]])}],tree:[{name:"Прояснить требования",handler:new Map([["Tree",d.ProgType.POINTS],["N/A",d.ProgType.POINTS]])},{name:"Утвердить требования",handler:new Map([["Tree",d.ProgType.LINES],["N/A",d.ProgType.LINES]])},{name:"Поставить ствол",handler:new Map([["Tree",d.ProgType.SIMPLE_LIGHT],["N/A",d.ProgType.LINES]])},{name:"Наклеить листву",handler:new Map([["Tree",d.ProgType.SIMPLE_LIGHT],["N/A",d.ProgType.SIMPLE_LIGHT]])},{name:"Рефакторинг",handler:new Map([["Tree",d.ProgType.SPECULAR_LIGHT],["N/A",d.ProgType.SPECULAR_LIGHT]])}]},e=document.getElementById("obj"),i=e.querySelector("canvas"),r={};for(const i of Object.keys(t))r[i]={e:e.querySelector(`button[name=${i}]`),reset:e.querySelector(`button[name=${i}] ~ button`)};const n=()=>{i.width=window.innerWidth,i.height=window.innerHeight};n(),window.addEventListener("resize",n);const s=(0,d.loadObjFile)("public/low-poly-mill.obj"),o=(0,d.loadMtlFile)("public/low-poly-mill.mtl");Promise.all([s,o]).then((e=>{const n=new d.default(i,e[0],e[1],3.1,[0,0,0]);for(const[e,i]of Object.entries(r)){let r=0;const s=t[e],o=()=>{r=Math.min(r+1,s.length-1),i.e.innerHTML=s[Math.min(r+1,s.length-1)].name,s[r].handler.forEach(((t,e)=>n.setProperty(e,t)))},a=()=>{r=0,i.e.innerHTML=s[r+1].name,i.reset.innerHTML="Начать заново",s[r].handler.forEach(((t,e)=>n.setProperty(e,t)))};i.e.addEventListener("click",o),i.reset.addEventListener("click",a),a()}}))}(),function(){const t=document.getElementById("snake"),e=t.querySelector("canvas"),i=new f.default(e),r=(e,r)=>{t.querySelector(`button[name=${e}]`).addEventListener("click",(()=>i.setDirection(r)))};r("up",f.Direction.UP),r("left",f.Direction.LEFT),r("down",f.Direction.DOWN),r("right",f.Direction.RIGHT);const n={ArrowUp:f.Direction.UP,ArrowLeft:f.Direction.LEFT,ArrowDown:f.Direction.DOWN,ArrowRight:f.Direction.RIGHT};document.addEventListener("keydown",(t=>{if(i.visible)for(const[e,r]of Object.entries(n))t.key===e&&(t.preventDefault(),i.setDirection(r))}))}(),function(){const t=document.getElementById("logo").querySelector("canvas"),e=()=>{t.width=window.innerWidth,t.height=window.innerHeight};e(),window.addEventListener("resize",e),new g.default(t,"public/logo.svg")}(),function(){const t=document.getElementById("maze"),e=t.querySelector("canvas"),i=()=>{e.width=window.innerWidth,e.height=window.innerHeight};i(),window.addEventListener("resize",i);const r=e=>{const i=t.querySelector(`input[name=${e}]`),r=t.querySelector(`input[name=${e}] ~ span`),n=()=>r.innerHTML=i.value;return n(),i.addEventListener("input",n),()=>parseInt(i.value)},n={width:r("width"),depth:r("depth")};let s=!1;const o=new m.default(e,n.width(),n.depth(),"public/maze.png",s),a=t.querySelector("button[name=mode]"),h=()=>{s=!s,o.setAuto(s),a.innerHTML=s?"Автоматический режим":"Ручной режим"};h(),a.addEventListener("click",h);const l=(e,i)=>{t.querySelector(`button[name=${e}]`).addEventListener("click",(()=>!s&&o.setAction(i)))};l("up",p.Action.UP),l("left",p.Action.LEFT),l("right",p.Action.RIGHT);const c={ArrowUp:p.Action.UP,ArrowLeft:p.Action.LEFT,ArrowRight:p.Action.RIGHT};document.addEventListener("keydown",(t=>{if(o.visible&&!s)for(const[e,i]of Object.entries(c))t.key===e&&(t.preventDefault(),o.setAction(i))})),t.querySelector("button[name=generate]").addEventListener("click",(()=>{o.initNewGameField(n.width(),n.depth(),s)}))}()},137:(t,e)=>{var i;Object.defineProperty(e,"__esModule",{value:!0}),e.setState=e.getState=e.State=void 0,function(t){t.DAY="day",t.NIGHT="night"}(i=e.State||(e.State={})),e.getState=function(t){return null!==document.querySelector(`#${t} .${i.DAY}`)?i.DAY:i.NIGHT},e.setState=function(t,e){const r=e===i.DAY?i.NIGHT:i.DAY,n=document.querySelector(`#${t} .${r}`);null!==n&&n.classList.replace(r,e)}},317:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t,e){this.colorIndex=0,this.x=0,this.right=!0,this.y=0,this.down=!0,this.w=t,this.h=e}update(t,e){this.x+=i.SPEED*(this.right?1:-1),this.y+=i.SPEED*(this.down?1:-1),this.x<0?(this.x=0,this.right=!0,this.colorIndex++):this.x+this.w>t&&(this.x=t-this.w,this.right=!1,this.colorIndex++),this.y<0?(this.y=0,this.down=!0,this.colorIndex++):this.y+this.h>e&&(this.y=e-this.h,this.down=!1,this.colorIndex++)}getRect(){return[this.x,this.y,this.x+this.w,this.y+this.h]}getColorIndex(){return this.colorIndex}}e.default=i,i.SPEED=2},78:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=i(300),s=r(i(921)),o=r(i(146)),a=r(i(317));class h{constructor(t,e){this.vertexCoordBuffer=new o.default(2*Uint16Array.BYTES_PER_ELEMENT*4),this.vertexTextureBuffer=new o.default(2*Uint8Array.BYTES_PER_ELEMENT*4),this.logo=null,this.el=t,this.initGLContext(e),this.drawNextFrame()}initGLContext(t){this.prog=new s.default(this.el,"\n            attribute vec2 a_position;\n            attribute vec2 a_texcoord;\n\n            uniform vec2 u_resolution;\n\n            varying vec2 v_texcoord;\n\n            void main() {\n              // [0; +oo] -> [0; 1] -> [0; 2] -> [-1; 1]\n              vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\n              gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            \n              v_texcoord = a_texcoord;\n            }\n        ","\n            precision mediump float;\n\n            varying vec2 v_texcoord;\n\n            uniform sampler2D u_texture;\n            uniform vec3 u_color;\n\n            void main() {\n              float alpha = texture2D(u_texture, v_texcoord).a;\n              if (alpha < 0.1) {\n                discard;\n              } else {\n                gl_FragColor = vec4(u_color, 1);\n              }\n            }\n        ",["a_position","a_texcoord"],["u_resolution","u_color","u_texture"]),this.prog.useProgram(),this.glVertexCoordBuffer=this.prog.createBuffer(),this.glVertexTextureBuffer=this.prog.createBuffer(),this.glTexture=this.prog.createTexture();const e=this.prog.gl;this.vertexTextureBuffer.write2Uint8(0,0),this.vertexTextureBuffer.write2Uint8(0,1),this.vertexTextureBuffer.write2Uint8(1,1),this.vertexTextureBuffer.write2Uint8(1,0),this.prog.arrayBuffer(this.glVertexTextureBuffer,2*Uint8Array.BYTES_PER_ELEMENT,{a_texcoord:{elems:2,elType:e.UNSIGNED_BYTE,normalized:!1,offsetBytes:0}},this.vertexTextureBuffer.rawBuffer),this.prog.textureFromBuf("u_texture",this.glTexture,e.ALPHA,new Uint8Array([0,0,0,0]),1,1,e.UNSIGNED_BYTE,0,!0);const i=new Image;i.crossOrigin="anonymous",i.onload=()=>{const t=i.width,r=i.height;this.logo=new a.default(t,r),this.prog.textureFromImg("u_texture",this.glTexture,e.ALPHA,i,e.UNSIGNED_BYTE,0,{generate:!1,wrapS:e.CLAMP_TO_EDGE,wrapT:e.CLAMP_TO_EDGE,minFilter:e.NEAREST,magFilter:e.NEAREST})},i.src=t}drawNextFrame(){window.requestAnimationFrame(this.drawNextFrame.bind(this));const t=this.prog.gl;if(!(0,n.isVisible)(t))return;(0,n.resizeContext)(t);const e=this.prog.width,i=this.prog.height;if(this.prog.useProgram(),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT),null===this.logo)return;this.logo.update(e,i);const r=this.logo.getRect();this.vertexCoordBuffer.clean(),this.vertexCoordBuffer.write2Uint16(r[0],r[1]),this.vertexCoordBuffer.write2Uint16(r[0],r[3]),this.vertexCoordBuffer.write2Uint16(r[2],r[3]),this.vertexCoordBuffer.write2Uint16(r[2],r[1]),this.prog.arrayBuffer(this.glVertexCoordBuffer,2*Uint16Array.BYTES_PER_ELEMENT,{a_position:{elems:2,elType:t.UNSIGNED_SHORT,normalized:!1,offsetBytes:0}},this.vertexCoordBuffer.rawBuffer);const s=this.logo.getColorIndex()%(h.COLORS.length/3);this.prog.uniformVector("u_color",h.COLORS[3*s],h.COLORS[3*s+1],h.COLORS[3*s+2]),this.prog.uniformVector("u_resolution",e,i),this.prog.drawArrays(t.TRIANGLE_FAN,4)}}e.default=h,h.COLORS=new Float32Array([190/255,0,1,0,254/255,1,1,131/255,0,0,38/255,1,1,250/255,1/255,1,38/255,0,1,0,139/255,37/255,1,1/255])},464:(t,e)=>{var i;Object.defineProperty(e,"__esModule",{value:!0}),e.Action=void 0,(i=e.Action||(e.Action={}))[i.UP=0]="UP",i[i.LEFT=1]="LEFT",i[i.RIGHT=2]="RIGHT"},330:(t,e)=>{var i;Object.defineProperty(e,"__esModule",{value:!0}),e.Direction=void 0,(i=e.Direction||(e.Direction={}))[i.North=1]="North",i[i.South=2]="South",i[i.West=4]="West",i[i.East=8]="East"},669:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0});const r=i(330);e.default=function(t,e){const i=t*e,n=new Uint8Array(i),s=new Uint8Array(i),o=(e,i)=>s[i*t+e]=1,a=(e,i,r)=>n[i*t+e]|=r;let h=[Math.floor(Math.random()*t),Math.floor(Math.random()*e)];const l=[h];for(o(h[0],h[1]);l.length>0;){const i=[[h[0]-1,h[1],r.Direction.West,r.Direction.East],[h[0],h[1]+1,r.Direction.North,r.Direction.South],[h[0]+1,h[1],r.Direction.East,r.Direction.West],[h[0],h[1]-1,r.Direction.South,r.Direction.North]].filter((i=>{return i[0]>=0&&i[0]<t&&i[1]>=0&&i[1]<e&&(r=i[0],n=i[1],!(1===s[n*t+r]));var r,n}));if(i.length>0){const t=i[Math.floor(Math.random()*i.length)];a(h[0],h[1],t[2]),a(t[0],t[1],t[3]),o(t[0],t[1]),h=[t[0],t[1]],l.push(h)}else h=l.pop()}return n}},556:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(i(669));e.default=class{constructor(t,e){this.w=t,this.h=e,this.cells=(0,n.default)(t,e)}hasWall(t,e,i){return 0==(this.cells[e*this.w+t]&i)}getWidth(){return this.w}getHeight(){return this.h}}},785:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0});const r=i(464),n=i(330);class s{constructor(t,e){this.currentMoveProgress=0,this.currentRotateProgress=0,this.maze=t,this.currentX=Math.floor(Math.random()*t.getWidth()),this.currentY=Math.floor(Math.random()*t.getHeight()),this.currentDirection=[n.Direction.North,n.Direction.South,n.Direction.West,n.Direction.East][Math.floor(4*Math.random())],this.auto=e}setAction(t){this.nextAction=t}getCurrentCell(){return[this.currentX,this.currentY]}getMoveProgress(){return this.currentMoveProgress}getDirection(){return this.currentDirection}getRotateProgress(){return this.currentRotateProgress}update(){switch(this.currentAction){case r.Action.UP:this.currentMoveProgress+=s.PROGRESS_SPEED,this.currentMoveProgress>=100&&(this.currentAction=void 0,this.currentMoveProgress=0,this.currentDirection===n.Direction.North?++this.currentY:this.currentDirection===n.Direction.South?--this.currentY:this.currentDirection===n.Direction.West?--this.currentX:this.currentDirection===n.Direction.East&&++this.currentX);break;case r.Action.LEFT:this.currentRotateProgress+=s.PROGRESS_SPEED,this.currentRotateProgress>=100&&(this.currentAction=void 0,this.currentRotateProgress=0,this.currentDirection=s.GetLeft(this.currentDirection));break;case r.Action.RIGHT:this.currentRotateProgress-=s.PROGRESS_SPEED,this.currentRotateProgress<=-100&&(this.currentAction=void 0,this.currentRotateProgress=0,this.currentDirection=s.GetRight(this.currentDirection));break;case void 0:if(void 0!==this.nextAction){let t=!0;this.nextAction===r.Action.UP&&this.maze.hasWall(this.currentX,this.currentY,this.currentDirection)&&(t=!1),t&&(this.currentAction=this.nextAction),this.nextAction=void 0}else if(this.auto){const t=!this.maze.hasWall(this.currentX,this.currentY,this.currentDirection),e=!this.maze.hasWall(this.currentX,this.currentY,s.GetLeft(this.currentDirection)),i=!this.maze.hasWall(this.currentX,this.currentY,s.GetRight(this.currentDirection));if(t)e||i?Math.random()<.8?this.nextAction=r.Action.UP:e&&i?this.nextAction=Math.random()<.5?r.Action.LEFT:r.Action.RIGHT:e?this.nextAction=r.Action.LEFT:i&&(this.nextAction=r.Action.RIGHT):this.nextAction=r.Action.UP;else if(e||i)e&&i?this.nextAction=Math.random()<.5?r.Action.LEFT:r.Action.RIGHT:e?this.nextAction=r.Action.LEFT:i&&(this.nextAction=r.Action.RIGHT);else{const t=Math.random()<.5?r.Action.LEFT:r.Action.RIGHT;this.currentAction=t,this.nextAction=t}}}}setAuto(t){this.auto=t}static GetLeft(t){switch(t){case n.Direction.North:return n.Direction.West;case n.Direction.West:return n.Direction.South;case n.Direction.South:return n.Direction.East;case n.Direction.East:return n.Direction.North;default:throw new Error("Invalid direction")}}static GetRight(t){switch(t){case n.Direction.North:return n.Direction.East;case n.Direction.East:return n.Direction.South;case n.Direction.South:return n.Direction.West;case n.Direction.West:return n.Direction.North;default:throw new Error("Invalid direction")}}}e.default=s,s.PROGRESS_SPEED=2},19:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(i(126)),s=r(i(921)),o=i(300),a=r(i(146)),h=i(330),l=r(i(556)),c=r(i(785));var u;!function(t){t[t.LEFT_WALL=0]="LEFT_WALL",t[t.RIGHT_WALL=1]="RIGHT_WALL",t[t.UP_WALL=2]="UP_WALL",t[t.DOWN_WALL=3]="DOWN_WALL",t[t.FLOOR=4]="FLOOR",t[t.CEIL=5]="CEIL"}(u||(u={}));class d{constructor(t,e,i,r,n){this.vertexBuffer=new a.default(4*Uint8Array.BYTES_PER_ELEMENT),this.instanceCellBuffer=new a.default(1),this.instanceTypeBuffer=new a.default(1),this.el=t,this.initGLContext(),this.initStaticBuffers(r),this.initNewGameField(e,i,n),this.drawNextFrame()}initGLContext(){const t=d.CELL_SIZE,e=d.SPRITE_WALL,i=d.SPRITE_CEIL,r=d.SPRITE_FLOOR,n=-t/2,o=-t/2,a=-t/2,h=t/2,l=t/2,c=t/2,f=`\n            attribute float a_vertexID; // 4 corners\n            attribute vec2 a_cellIndex; // [0..i]\n            attribute float a_type; // Primitive enum\n\n            uniform mat4 u_worldProjectionMatrix;\n\n            varying vec2 v_texcoord;\n\n            bool equals(float v1, int v2) {\n                return abs(v1 - float(v2)) < 0.0001;\n            }\n\n            vec4 position() {\n              int index = int(a_vertexID);\n              if (equals(a_type, ${u.UP_WALL})) {\n                ${[[n,o],[h,o],[n,l],[h,l]].map(((t,e)=>`if (index == ${e}) return vec4(${t[0]}, ${t[1]}, ${c}, 1);`)).join(" else ")}\n              } else if (equals(a_type, ${u.LEFT_WALL})) {\n                ${[[a,o],[c,o],[a,l],[c,l]].map(((t,e)=>`if (index == ${e}) return vec4(${n}, ${t[1]}, ${t[0]}, 1);`)).join(" else ")}\n              } else if (equals(a_type, ${u.RIGHT_WALL})) {\n                ${[[c,o],[a,o],[c,l],[a,l]].map(((t,e)=>`if (index == ${e}) return vec4(${h}, ${t[1]}, ${t[0]}, 1);`)).join(" else ")}\n              } else if (equals(a_type, ${u.DOWN_WALL})) {\n                ${[[h,o],[n,o],[h,l],[n,l]].map(((t,e)=>`if (index == ${e}) return vec4(${t[0]}, ${t[1]}, ${a}, 1);`)).join(" else ")}\n              } else if (equals(a_type, ${u.CEIL})) {\n                ${[[n,c],[h,c],[n,a],[h,a]].map(((t,e)=>`if (index == ${e}) return vec4(${t[0]}, ${l}, ${t[1]}, 1);`)).join(" else ")}\n              } else if (equals(a_type, ${u.FLOOR})) {\n                ${[[n,a],[h,a],[n,c],[h,c]].map(((t,e)=>`if (index == ${e}) return vec4(${t[0]}, ${o}, ${t[1]}, 1);`)).join(" else ")}\n              }\n              // fallback, never happens\n              return vec4(0, 0, 0, 1);\n            }\n\n            vec2 texcoord() {\n              int index = int(a_vertexID);\n              if (equals(a_type, ${u.UP_WALL}) || equals(a_type, ${u.LEFT_WALL}) || equals(a_type, ${u.RIGHT_WALL}) || equals(a_type, ${u.DOWN_WALL})) {\n                ${[[e[0],e[3]],[e[2],e[3]],[e[0],e[1]],[e[2],e[1]]].map(((t,e)=>`if (index == ${e}) return vec2(${t[0]}, ${t[1]});`)).join(" else ")}\n              } else if (equals(a_type, ${u.CEIL})) {\n                ${[[i[0],i[3]],[i[2],i[3]],[i[0],i[1]],[i[2],i[1]]].map(((t,e)=>`if (index == ${e}) return vec2(${t[0]}, ${t[1]});`)).join(" else ")}\n              } else if (equals(a_type, ${u.FLOOR})) {\n                ${[[r[0],r[3]],[r[2],r[3]],[r[0],r[1]],[r[2],r[1]]].map(((t,e)=>`if (index == ${e}) return vec2(${t[0]}, ${t[1]});`)).join(" else ")}\n              }\n              // fallback, never happens\n              return vec2(0, 0);\n            }\n\n            void main() {\n              vec2 offset = a_cellIndex * vec2(${t}, ${t});\n              gl_Position = u_worldProjectionMatrix * (position() + vec4(offset.x, 0, offset.y, 0)) * vec4(-1, 1, 1, 1);\n\n              v_texcoord = texcoord();\n            }\n        `;this.prog=new s.default(this.el,f,"\n            precision mediump float;\n            \n            uniform sampler2D u_texture;\n            varying vec2 v_texcoord;\n            \n            void main() {\n              gl_FragColor = texture2D(u_texture, v_texcoord);\n            }\n        ",["a_vertexID","a_cellIndex","a_type"],["u_worldProjectionMatrix","u_texture"]),this.prog.gl.enable(this.prog.gl.CULL_FACE),this.prog.gl.enable(this.prog.gl.DEPTH_TEST),this.glVertexBuffer=this.prog.createBuffer(),this.glInstanceCellBuffer=this.prog.createBuffer(),this.glInstanceTypeBuffer=this.prog.createBuffer(),this.glTexture=this.prog.createTexture()}initStaticBuffers(t){const e=this.prog.gl;this.prog.useProgram(),this.vertexBuffer.write2Uint8(0,1),this.vertexBuffer.write2Uint8(2,3),this.prog.arrayBuffer(this.glVertexBuffer,Uint8Array.BYTES_PER_ELEMENT,{a_vertexID:{elems:1,elType:e.UNSIGNED_BYTE,normalized:!1,offsetBytes:0}},this.vertexBuffer.rawBuffer),this.prog.textureFromBuf("u_texture",this.glTexture,e.RGB,new Uint8Array([0,0,0,0]),1,1,e.UNSIGNED_BYTE,0,!0);const i=new Image;i.crossOrigin="anonymous",i.onload=()=>{this.prog.textureFromImg("u_texture",this.glTexture,e.RGB,i,e.UNSIGNED_BYTE,0,{generate:!1,wrapS:e.CLAMP_TO_EDGE,wrapT:e.CLAMP_TO_EDGE,minFilter:e.NEAREST,magFilter:e.NEAREST})},i.src=t}drawNextFrame(){window.requestAnimationFrame(this.drawNextFrame.bind(this));const t=this.prog.gl;if((0,o.isVisible)(t)){(0,o.resizeContext)(t),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),this.runner.update();{let t=Math.PI/2*this.runner.getRotateProgress()/100;switch(this.runner.getDirection()){case h.Direction.North:t+=0;break;case h.Direction.South:t+=Math.PI;break;case h.Direction.West:t+=Math.PI/2;break;case h.Direction.East:t+=Math.PI+Math.PI/2}let[e,i]=this.runner.getCurrentCell().map((t=>t*d.CELL_SIZE));switch(this.runner.getDirection()){case h.Direction.North:i+=d.CELL_SIZE*this.runner.getMoveProgress()/100;break;case h.Direction.South:i-=d.CELL_SIZE*this.runner.getMoveProgress()/100;break;case h.Direction.West:e-=d.CELL_SIZE*this.runner.getMoveProgress()/100;break;case h.Direction.East:e+=d.CELL_SIZE*this.runner.getMoveProgress()/100}const r=n.default.LookAt(e,0,i,e-Math.sin(t),0,i+Math.cos(t),0,1,0),s=n.default.Perspective(3*Math.PI/5,this.prog.width/this.prog.height,1,Math.max(this.maze.getWidth(),this.maze.getHeight())*d.CELL_SIZE);s.multiply(r),this.prog.uniformMatrix("u_worldProjectionMatrix",s.data)}this.prog.drawArraysInstanced(t.TRIANGLE_STRIP,4,this.instanceTypeBuffer.bytes)}}initNewGameField(t,e,i){this.maze=new l.default(t,e),this.runner=new c.default(this.maze,i);const r=[[h.Direction.North,u.UP_WALL],[h.Direction.South,u.DOWN_WALL],[h.Direction.West,u.LEFT_WALL],[h.Direction.East,u.RIGHT_WALL]];let n=0;for(let i=0;i<e;i++)for(let e=0;e<t;e++){n+=2;for(const t of r)this.maze.hasWall(e,i,t[0])&&++n}this.instanceCellBuffer.reserveAndClean(2*Uint16Array.BYTES_PER_ELEMENT*n),this.instanceTypeBuffer.reserveAndClean(Uint8Array.BYTES_PER_ELEMENT*n);for(let i=0;i<e;i++)for(let e=0;e<t;e++)for(const t of r)this.maze.hasWall(e,i,t[0])&&(this.instanceCellBuffer.write2Uint16(e,i),this.instanceTypeBuffer.write1Uint8(t[1]));for(let i=0;i<e;i++)for(let e=0;e<t;e++)this.instanceCellBuffer.write2Uint16(e,i),this.instanceCellBuffer.write2Uint16(e,i),this.instanceTypeBuffer.write1Uint8(u.CEIL),this.instanceTypeBuffer.write1Uint8(u.FLOOR);const s=this.prog.gl;this.prog.arrayBuffer(this.glInstanceCellBuffer,2*Uint16Array.BYTES_PER_ELEMENT,{a_cellIndex:{elems:2,elType:s.UNSIGNED_SHORT,normalized:!1,offsetBytes:0}},this.instanceCellBuffer.rawBuffer),this.prog.markAttributeInstanced("a_cellIndex"),this.prog.arrayBuffer(this.glInstanceTypeBuffer,Uint8Array.BYTES_PER_ELEMENT,{a_type:{elems:1,elType:s.UNSIGNED_BYTE,normalized:!1,offsetBytes:0}},this.instanceTypeBuffer.rawBuffer),this.prog.markAttributeInstanced("a_type")}setAction(t){this.runner.setAction(t)}setAuto(t){this.runner.setAuto(t)}get visible(){return(0,o.isVisible)(this.prog.gl)}}e.default=d,d.CELL_SIZE=100,d.SPRITE_WALL=[0,0,128/192,1],d.SPRITE_FLOOR=[128/192,0,1,.5],d.SPRITE_CEIL=[128/192,.5,161/192,97/128]},442:function(t,e,i){var r=this&&this.__awaiter||function(t,e,i,r){return new(i||(i=Promise))((function(n,s){function o(t){try{h(r.next(t))}catch(t){s(t)}}function a(t){try{h(r.throw(t))}catch(t){s(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(o,a)}h((r=r.apply(t,e||[])).next())}))},n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.ProgType=e.loadMtlFile=e.loadObjFile=void 0;const s=n(i(391)),o=i(674),a=n(i(921)),h=n(i(146)),l=n(i(333)),c=i(300),u=n(i(126));var d;e.loadObjFile=function(t){return r(this,void 0,void 0,(function*(){const e=yield fetch(t),i=yield e.text();return s.default.parse(i)}))},e.loadMtlFile=function(t){return r(this,void 0,void 0,(function*(){const e=yield fetch(t),i=yield e.text();return(0,o.parseMTL)(i)}))},function(t){t[t.DO_NOT_DRAW=0]="DO_NOT_DRAW",t[t.POINTS=1]="POINTS",t[t.LINES=2]="LINES",t[t.SIMPLE_LIGHT=3]="SIMPLE_LIGHT",t[t.SPECULAR_LIGHT=4]="SPECULAR_LIGHT"}(d=e.ProgType||(e.ProgType={})),e.default=class{constructor(t,e,i,r,n){this.progs=new Map,this.vertexBuffer=new h.default(1),this.indexBuffer=new l.default(1),this.cameraRotation=0,this.rotationSpeed=Math.PI/200,e.geometries.forEach((t=>t.name=t.name||"N/A")),this.el=t,this.obj=e,this.mtl=i,this.prop=new Map(this.obj.geometries.map((t=>[t.name,d.SIMPLE_LIGHT]))),this.background=[...n,1],this.objCoordRange=e.getSize(),this.initGLContext(),this.compilePrograms(r),this.fillBuffers(),this.drawNextFrame()}initGLContext(){const t=new a.default(this.el,"void main() { gl_Position = vec4(0, 0, 0, 0); }","void main() { gl_FragColor = vec4(0, 0, 0, 0); }",[],[]).gl;t.enable(t.DEPTH_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),this.glVertexBuffer=t.createBuffer(),this.glIndexBuffer=t.createBuffer()}compilePrograms(t){const e=`\n          attribute vec4 a_position;\n          attribute vec3 a_normal;\n        \n          uniform mat4 u_worldMatrix;\n          uniform mat4 u_worldProjectionMatrix;\n          uniform vec3 u_viewWorldPosition; // camera\n        \n          varying vec3 v_normal;\n          varying vec3 v_surfaceToView;\n        \n          void main() {\n            gl_Position = u_worldProjectionMatrix * a_position;\n            gl_PointSize = ${t};\n            v_normal = mat3(u_worldMatrix) * a_normal;\n            // vector vertex->camera\n            v_surfaceToView = u_viewWorldPosition - (u_worldMatrix * a_position).xyz;\n          }\n        `,i=["a_position","a_normal"],r=["u_worldMatrix","u_worldProjectionMatrix","u_lightDirection","u_viewWorldPosition","diffuse","ambient","u_ambientLight","emissive","specular","shininess","opacity"];{const t="\n                #ifdef GL_FRAGMENT_PRECISION_HIGH\n                    precision highp float;\n                #else\n                    precision mediump float;\n                #endif\n                \n                varying vec3 v_normal;\n                varying vec3 v_surfaceToView;\n              \n                // material color\n                uniform vec3 diffuse;\n                // uniform sampler2D diffuseMap;\n                \n                // ambient light (sky, sun, ...)\n                uniform vec3 ambient;\n                uniform vec3 u_ambientLight;\n                \n                // light, which is generated by material\n                uniform vec3 emissive;\n                \n                // reflection light and its force\n                uniform vec3 specular;\n                // uniform sampler2D specularMap;\n                uniform float shininess; // 1 - strong, 2 - smooth\n                \n                uniform float opacity;\n                \n                uniform vec3 u_lightDirection;\n              \n                void main () {\n                  vec4 v_color = vec4(1, 1, 1, 1);\n                  vec3 normal = normalize(v_normal);\n              \n                  vec3 surfaceToViewDirection = normalize(v_surfaceToView);\n                  \n                  // vector between camera and light \n                  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);\n                  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);\n                  //vec4 specularMapColor = texture2D(specularMap, v_texcoord);\n                  vec4 specularMapColor = vec4(1, 1, 1, 1);\n                  vec3 effectiveSpecular = specular * specularMapColor.rgb;\n              \n                  float fakeLight = dot(u_lightDirection, normal) * .25;\n                  //vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);\n                  vec4 diffuseMapColor = vec4(1, 1, 1, 1);\n                  vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;\n                  float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;\n              \n                  gl_FragColor = vec4(\n                      emissive +\n                      ambient * u_ambientLight +\n                      effectiveDiffuse * fakeLight +\n                      effectiveSpecular * pow(specularLight, shininess),\n                      effectiveOpacity);\n                }\n            ";this.progs.set(d.SPECULAR_LIGHT,new a.default(this.el,e,t,i,r))}{const t="\n                #ifdef GL_FRAGMENT_PRECISION_HIGH\n                    precision highp float;\n                #else\n                    precision mediump float;\n                #endif\n                \n                varying vec3 v_normal;\n                varying vec3 v_surfaceToView;\n              \n                uniform vec3 diffuse;\n                uniform vec3 ambient;\n                uniform vec3 u_ambientLight;\n                uniform vec3 emissive;\n                uniform vec3 specular;\n                uniform float shininess;\n                uniform float opacity;\n                uniform vec3 u_lightDirection;\n              \n                void main () {\n                  vec3 normal = normalize(v_normal);\n                  vec3 lightDirection = normalize(u_lightDirection);\n                  \n                  float light = dot(normal, lightDirection);\n                  \n                  gl_FragColor = vec4(normalize(diffuse) * light, 1);\n                }\n            ";this.progs.set(d.SIMPLE_LIGHT,new a.default(this.el,e,t,i,r))}{const t="\n                #ifdef GL_FRAGMENT_PRECISION_HIGH\n                    precision highp float;\n                #else\n                    precision mediump float;\n                #endif\n                \n                varying vec3 v_normal;\n                varying vec3 v_surfaceToView;\n              \n                uniform vec3 diffuse;\n                uniform vec3 ambient;\n                uniform vec3 u_ambientLight;\n                uniform vec3 emissive;\n                uniform vec3 specular;\n                uniform float shininess;\n                uniform float opacity;\n                uniform vec3 u_lightDirection;\n              \n                void main () {\n                  gl_FragColor = vec4(normalize(diffuse), 1);\n                }\n            ";this.progs.set(d.LINES,new a.default(this.el,e,t,i,r))}{const t="\n                #ifdef GL_FRAGMENT_PRECISION_HIGH\n                    precision highp float;\n                #else\n                    precision mediump float;\n                #endif\n                \n                varying vec3 v_normal;\n                varying vec3 v_surfaceToView;\n              \n                uniform vec3 diffuse;\n                uniform vec3 ambient;\n                uniform vec3 u_ambientLight;\n                uniform vec3 emissive;\n                uniform vec3 specular;\n                uniform float shininess;\n                uniform float opacity;\n                uniform vec3 u_lightDirection;\n              \n                void main () {\n                  gl_FragColor = vec4(normalize(diffuse), 1);\n                }\n            ";this.progs.set(d.POINTS,new a.default(this.el,e,t,i,r))}}fillBuffers(){this.vertexBuffer.reserveAndClean(3*this.obj.getTriangleCount()*(6*Float32Array.BYTES_PER_ELEMENT)),this.indexBuffer.reserveAndClean(3*this.obj.getTriangleCount()*Uint16Array.BYTES_PER_ELEMENT);for(const t of this.obj.geometries)for(const e of t.triangles){const t=this.obj.getPositionOf(e[0]),i=this.obj.getPositionOf(e[1]),r=this.obj.getPositionOf(e[2]),n=[t[0]-i[0],t[1]-i[1],t[2]-i[2]],s=[t[0]-r[0],t[1]-r[1],t[2]-r[2]],o=[n[1]*s[2]-n[2]*s[1],-n[0]*s[2]+n[2]*s[0],n[0]*s[1]-n[1]*s[0]];for(const e of[t,i,r])this.vertexBuffer.write3Float32(...e),this.vertexBuffer.write3Float32(...o),this.indexBuffer.write1Uint16(this.indexBuffer.nextIndex)}const t=Float32Array.BYTES_PER_ELEMENT;for(const e of this.progs.values()){const i=e.gl;e.arrayBuffer(this.glVertexBuffer,6*t,{a_position:{elems:3,elType:i.FLOAT,normalized:!1,offsetBytes:0},a_normal:{elems:3,elType:i.FLOAT,normalized:!1,offsetBytes:3*t}},this.vertexBuffer.sliceFloat32()),e.indexBuffer(this.glIndexBuffer,this.indexBuffer.sliceUint16())}}drawNextFrame(){window.requestAnimationFrame(this.drawNextFrame.bind(this));const t=this.progs.values().next().value.gl;if((0,c.isVisible)(t)){(0,c.resizeContext)(t),t.clearColor(...this.background),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT);{this.cameraRotation-=this.rotationSpeed,this.cameraRotation<2*-Math.PI&&(this.cameraRotation=0);const e=[0,0,0];for(let t=0;t<3;++t)e[t]=this.objCoordRange.min[t]+(this.objCoordRange.max[t]-this.objCoordRange.min[t])/2;const i=u.default.XRotate(Math.PI/6).yRotate(this.cameraRotation).translate(-e[0],-e[1],-e[2]),r=1.2*Math.sqrt(Math.pow(this.objCoordRange.max[0]-this.objCoordRange.min[0],2)+Math.pow(this.objCoordRange.max[1]-this.objCoordRange.min[1],2)+Math.pow(this.objCoordRange.max[2]-this.objCoordRange.min[2],2)),n=r/1e3,s=3*r,o=t.canvas.clientWidth/t.canvas.clientHeight,a=[0,0,r],h=u.default.Perspective(60*Math.PI/180,o,n,s);h.multiply(u.default.LookAt(a[0],a[1],a[2],0,0,0,0,1,0)),h.multiply(i);let l=0;for(const e of this.obj.geometries){const r=this.prop.get(e.name);if(void 0===r||r===d.DO_NOT_DRAW){l+=3*e.triangles.length;continue}const n=this.progs.get(r);n.useProgram(),n.uniformMatrix("u_worldMatrix",i.data),n.uniformMatrix("u_worldProjectionMatrix",h.data),n.uniformVector("u_lightDirection",1,3,5),n.uniformVector("u_viewWorldPosition",...a);const s=this.mtl.get(e.material||"");n.uniformVector("diffuse",...(null==s?void 0:s.diffuse)||[1,1,1]),n.uniformVector("ambient",...(null==s?void 0:s.ambient)||[0,0,0]),n.uniformVector("u_ambientLight",.1,.1,.1),n.uniformVector("emissive",...(null==s?void 0:s.emissive)||[0,0,0]),n.uniformVector("specular",...(null==s?void 0:s.specular)||[1,1,1]),n.uniformVector("shininess",(null==s?void 0:s.shininess)||400),n.uniformVector("opacity",(null==s?void 0:s.opacity)||1);const o=3*e.triangles.length,c=r===d.POINTS?t.POINTS:r===d.LINES?t.LINE_LOOP:t.TRIANGLES;n.drawElements(c,o,t.UNSIGNED_SHORT,l*Uint16Array.BYTES_PER_ELEMENT),l+=o}}}}get objectNames(){return this.obj.geometries.map((t=>t.name))}setProperty(t,e){this.prop.set(t,e)}}},403:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=class{constructor(t){this.mask=null,this.w=0,this.h=0,this.scaledW=0,this.scaledH=0,this.canvasW=0,this.canvasH=0,this.scale=1;const e=new Image;e.crossOrigin="anonymous",e.onload=this.onMaskLoaded.bind(this,e),e.src=t}updateScale(t,e){this.mask&&(this.canvasW=t,this.canvasH=e,this.scale=Math.min(t/this.w,e/this.h),this.scaledW=this.w*this.scale,this.scaledH=this.h*this.scale)}toMaskPixelCoordinate(t,e){let i=Math.abs(this.scaledW-this.canvasW)/2,r=Math.abs(this.scaledH-this.canvasH)/2;return i>r?r=0:i=0,[(t-i)/this.scale|0,(e-r)/this.scale|0]}isIntersect(t,e){return!this.mask||([t,e]=this.toMaskPixelCoordinate(t,e),this.read(t,e))}isConnected(t,e,i,r){if(!this.mask)return!0;if([t,e]=this.toMaskPixelCoordinate(t,e),[i,r]=this.toMaskPixelCoordinate(i,r),t===i){const i=Math.min(e,r),n=Math.max(e,r);for(let e=i;e<=n;++e)if(!this.read(t,e))return!1;return!0}const n=(e-r)/(t-i),s=e-t*n;if(Math.abs(n)>=1){const t=Math.min(e,r),i=Math.max(e,r);for(let e=t;e<=i;++e)if(!this.read((e-s)/n|0,e))return!1;return!0}{const e=Math.min(t,i),r=Math.max(t,i);for(let t=e;t<=r;++t)if(!this.read(t,n*t+s|0))return!1;return!0}}read(t,e){if(this.mask){if(t<this.w&&e<this.h&&t>=0&&e>=0){const i=this.w*e+t;return 0!==this.mask[i]}return!1}return!0}write(t,e,i){if(this.mask){const r=this.w*e+t;this.mask[r]=i?1:0}}onMaskLoaded(t){const e=document.createElement("canvas"),i=this.w=e.width=t.width,r=this.h=e.height=t.height,n=e.getContext("2d");n.drawImage(t,0,0);const s=n.getImageData(0,0,i,r),o=new Uint32Array(s.data.buffer);this.mask=new Int8Array(this.w*this.h);for(let t=0;t<r;++t)for(let e=0;e<i;++e){const i=(16777215&o[s.width*t+e])>0;this.write(e,t,i)}}}},299:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=class{constructor(t,e){this.x=Math.random()*t,this.y=Math.random()*e;const i=Math.random()*Math.PI*2;this.vx=2*Math.cos(i),this.vy=2*Math.sin(i)}update(t,e){this.x+=this.vx,this.y+=this.vy;let i=!0;this.x<0?this.x=0:this.x>t?this.x=t:i=!1,i&&(this.vx*=-1);let r=!0;this.y<0?this.y=0:this.y>e?this.y=e:r=!1,r&&(this.vy*=-1)}}},522:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(i(299)),s=i(300),o=r(i(921)),a=r(i(146)),h=r(i(333));e.default=class{constructor(t,e,i){this.vertexBuffer=new a.default(1),this.indexBuffer=new h.default(1),this.particles=[],this.springConst=25e-6,this.el=t,this.mask=i;const r=this.el.clientWidth,s=this.el.clientHeight;for(let t=0;t<e;++t)this.particles.push(new n.default(r,s));this.initGLContext(),this.drawNextFrame()}initGLContext(){this.lineProg=new o.default(this.el,"\n            attribute vec2 a_position;\n            \n            uniform vec2 u_resolution;\n\n            void main() {\n              // [0; +oo] -> [0; 1] -> [0; 2] -> [-1; 1]\n              vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\n              gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            }\n        ","\n            precision mediump float;\n            void main() {\n              gl_FragColor = vec4(0.75, 0.75, 0.75, 1); // #CCC\n            }\n        ",["a_position"],["u_resolution"]),this.pointProg=new o.default(this.el,"\n            attribute vec2 a_position;\n            \n            uniform vec2 u_resolution;\n            \n            varying vec2 v_pos;\n\n            void main() {\n              // [0; +oo] -> [0; 1] -> [0; 2] -> [-1; 1]\n              vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\n              gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n              \n              gl_PointSize = 7.0;\n\n              v_pos = gl_Position.xy;\n            }\n        ","\n            precision mediump float;\n            \n            varying vec2 v_pos;\n\n            void main() {\n              if (abs(distance(v_pos, gl_FragCoord.xy)) < 10.0) {\n                discard;\n              }\n              \n              // [-1; 1] -> [0; 1] \n              gl_FragColor = vec4(v_pos * 0.5 + 0.5, 0.5, 1);\n            }\n        ",["a_position"],["u_resolution"]),this.glVertexBuffer=this.pointProg.createBuffer(),this.glIndexBuffer=this.pointProg.createBuffer()}drawNextFrame(){var t;window.requestAnimationFrame(this.drawNextFrame.bind(this));const e=this.lineProg.gl;if(!(0,s.isVisible)(e))return;(0,s.resizeContext)(e);const i=this.lineProg.width,r=this.lineProg.height;null===(t=this.mask)||void 0===t||t.updateScale(i,r);const n=2*this.particles.length*Uint16Array.BYTES_PER_ELEMENT;this.vertexBuffer.reserveAndClean(n);const o=this.particles.length*this.particles.length*2*Uint16Array.BYTES_PER_ELEMENT;this.indexBuffer.reserveAndClean(o),this.particles.forEach((t=>{t.update(i,r),this.vertexBuffer.write2Uint16(t.x,t.y)}));const a=10*i;for(let t=0;t<this.particles.length;++t){const e=this.particles[t];if(!this.mask||this.mask.isIntersect(e.x,e.y))for(let i=t+1;i<this.particles.length;++i){const r=this.particles[i];if(this.mask&&!this.mask.isIntersect(r.x,r.y))continue;const n=e.x-r.x,s=e.y-r.y;if(n*n+s*s<a){if(this.mask&&!this.mask.isConnected(e.x,e.y,r.x,r.y))continue;e.vx-=n*this.springConst,e.vy-=s*this.springConst,r.vx+=n*this.springConst,r.vy+=s*this.springConst,this.indexBuffer.write2Uint16(t,i)}}}e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),this.lineProg.useProgram(),this.lineProg.arrayBuffer(this.glVertexBuffer,2*Uint16Array.BYTES_PER_ELEMENT,{a_position:{elems:2,elType:e.UNSIGNED_SHORT,normalized:!1,offsetBytes:0}},this.vertexBuffer.sliceUint16()),this.lineProg.indexBuffer(this.glIndexBuffer,this.indexBuffer.sliceUint16()),this.lineProg.uniformVector("u_resolution",i,r),this.lineProg.drawElements(e.LINES,this.indexBuffer.bytes/2,e.UNSIGNED_SHORT),this.pointProg.useProgram(),this.pointProg.arrayBuffer(this.glVertexBuffer,2*Uint16Array.BYTES_PER_ELEMENT,{a_position:{elems:2,elType:e.UNSIGNED_SHORT,normalized:!1,offsetBytes:0}}),this.pointProg.uniformVector("u_resolution",i,r),this.pointProg.drawArrays(e.POINTS,this.particles.length)}}},425:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t,e){this.arr=[[t,e]]}*[Symbol.iterator](){for(const t of this.arr)yield t}isSnake(t,e,i){return this.arr.some(((r,n)=>!(i&&0===n)&&r[0]===t&&r[1]===e))}add(t,e){this.arr.push([t,e])}move(t,e){this.arr.shift(),this.add(t,e)}get length(){return this.arr.length}get head(){return this.arr[this.arr.length-1]}}e.default=i},447:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.Direction=void 0;const n=i(300),s=r(i(921)),o=r(i(146)),a=r(i(425));var h;!function(t){t[t.UP=0]="UP",t[t.DOWN=1]="DOWN",t[t.LEFT=2]="LEFT",t[t.RIGHT=3]="RIGHT"}(h=e.Direction||(e.Direction={}));class l{constructor(t){this.vertexBuffer=new o.default(2*Float32Array.BYTES_PER_ELEMENT*4),this.instanceOffsetBuffer=new o.default(l.width*l.height*(2*Uint8Array.BYTES_PER_ELEMENT)),this.instanceColorBuffer=new o.default(l.width*l.height*Uint8Array.BYTES_PER_ELEMENT),this.el=t,this.initGLContext(),this.initBuffersAndUniform(),this.initGameField(),this.drawNextFrame()}initGLContext(){const t=`\n            precision mediump float;\n            varying float v_active;\n            \n            void main() {\n              if (v_active > 0.5) {\n                gl_FragColor = vec4(${l.ACTIVE_CELL[0]}, ${l.ACTIVE_CELL[1]}, ${l.ACTIVE_CELL[2]}, 1.0);\n              } else {\n                gl_FragColor = vec4(${l.EMPTY_CELL[0]}, ${l.EMPTY_CELL[1]}, ${l.EMPTY_CELL[2]}, 1.0);\n              }\n            }\n        `;this.prog=new s.default(this.el,"\n            attribute vec2 a_position; // [0..+oo]\n            attribute vec2 a_cellIndex; // [0..i]\n            attribute float a_active; // 0 or 1\n\n            uniform vec2 u_padding;\n            uniform vec2 u_cellSize;\n\n            varying float v_active;\n\n            void main() {\n              vec2 offsetFromTopLeftCorner = a_cellIndex * u_cellSize;\n              vec2 padding = u_padding * vec2(a_position.x == 0.0 ? 1 : -1, a_position.y == 0.0 ? -1 : 1);\n              vec2 position = vec2(-1, 1) + offsetFromTopLeftCorner + a_position + padding;\n              gl_Position = vec4(position * vec2(1, -1), 0, 1);\n              \n              v_active = a_active;\n            }\n        ",t,["a_position","a_cellIndex","a_active"],["u_padding","u_cellSize"]),this.glVertexBuffer=this.prog.createBuffer(),this.glInstanceOffsetBuffer=this.prog.createBuffer(),this.glInstanceColorBuffer=this.prog.createBuffer()}initBuffersAndUniform(){const t=2/l.width,e=2/l.height;this.vertexBuffer.write2Float32(0,0),this.vertexBuffer.write2Float32(t,0),this.vertexBuffer.write2Float32(t,-e),this.vertexBuffer.write2Float32(0,-e);const i=this.prog.gl;this.prog.useProgram(),this.prog.arrayBuffer(this.glVertexBuffer,2*Float32Array.BYTES_PER_ELEMENT,{a_position:{elems:2,elType:i.FLOAT,normalized:!1,offsetBytes:0}},this.vertexBuffer.rawBuffer),this.prog.uniformVector("u_cellSize",t,-e);for(let t=0;t<l.height;++t)for(let e=0;e<l.width;++e)this.instanceOffsetBuffer.write2Uint8(e,t);this.prog.arrayBuffer(this.glInstanceOffsetBuffer,2*Uint8Array.BYTES_PER_ELEMENT,{a_cellIndex:{elems:2,elType:i.UNSIGNED_BYTE,normalized:!1,offsetBytes:0}},this.instanceOffsetBuffer.rawBuffer),this.prog.markAttributeInstanced("a_cellIndex")}static randomApple(t){const e=l.width*l.height-t.length;let i=Math.round(Math.random()*e);for(let e=0;e<l.height;++e)for(let r=0;r<l.width;++r)if(!t.isSnake(r,e,!1)){if(0===i)return[r,e];--i}return[Math.trunc(Math.random()*l.width),Math.trunc(Math.random()*l.height)]}static nextSnakeHead(t,e){const i=e==h.LEFT?-1:e==h.RIGHT?1:0,r=-(e==h.UP?-1:e==h.DOWN?1:0),n=t.head,s=(n[0]+i)%l.width,o=(n[1]+r)%l.height;return[s<0?s+l.width:s,o<0?o+l.height:o]}initGameField(){this.snake=new a.default(Math.round(l.width/2),Math.round(l.height/2)),this.direction=h.UP,this.apple=l.randomApple(this.snake),this.speed=500}updateGameField(){const t=l.nextSnakeHead(this.snake,this.direction);t[0]===this.apple[0]&&t[1]===this.apple[1]?(this.snake.add(t[0],t[1]),this.apple=l.randomApple(this.snake),this.speed=Math.max(l.speed_max,this.speed-l.speed_delta)):this.snake.isSnake(...t,!0)?this.initGameField():this.snake.move(t[0],t[1])}drawNextFrame(){setTimeout(this.drawNextFrame.bind(this),this.speed),this.updateGameField();const t=this.prog.gl;(0,n.resizeContext)(t),t.clearColor(...l.BACKGROUND,1),t.clear(t.COLOR_BUFFER_BIT),this.prog.useProgram(),this.instanceColorBuffer.clean();for(let t=0;t<l.height;++t)for(let e=0;e<l.width;++e){const i=this.snake.isSnake(e,t,!1)||e===this.apple[0]&&t===this.apple[1];this.instanceColorBuffer.write1Uint8(i?1:0)}this.prog.arrayBuffer(this.glInstanceColorBuffer,Uint8Array.BYTES_PER_ELEMENT,{a_active:{elems:1,elType:t.UNSIGNED_BYTE,normalized:!1,offsetBytes:0}},this.instanceColorBuffer.rawBuffer),this.prog.markAttributeInstanced("a_active");const e=2/this.prog.width,i=2/this.prog.height;this.prog.uniformVector("u_padding",.8*e,.8*i),this.prog.drawArraysInstanced(t.LINE_LOOP,4,l.width*l.height),this.prog.uniformVector("u_padding",2*e,2*i),this.prog.drawArraysInstanced(t.TRIANGLE_FAN,4,l.width*l.height)}setDirection(t){const e=l.nextSnakeHead(this.snake,t);this.snake.isSnake(...e,!0)||(this.direction=t)}get visible(){return(0,n.isVisible)(this.prog.gl)}}e.default=l,l.BACKGROUND=[137/255,151/255,116/255],l.EMPTY_CELL=[131/255,141/255,114/255],l.ACTIVE_CELL=[0,0,0],l.width=10,l.height=20,l.speed_max=100,l.speed_delta=30},770:function(t,e,i){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=i(300),s=i(325),o=r(i(126)),a=r(i(146)),h=r(i(333)),l=r(i(921));class c{constructor(t,e,i,r,n,s,o,l){this.grid=[],this.gridSize=200,this.maxHeight=600,this.minHeight=100,this.vertexBuffer=new a.default(1),this.indexBuffer=new h.default(1),this.staticTriangles=0,this.cameraRotation=0,this.rotationSpeed=Math.PI/1e3,this.paused=!1,this.el=t,this.bgColor=e,this.gridWidth=i,this.gridHeight=n,this.heightFactor=5/r,this.roads=s,this.population=Math.min(o/10,1),this.vegetation=Math.min(l/10,1),this.initGLContext(),this.generateGrid(),this.fillStaticBuffers(),this.drawNextFrame()}initGLContext(){this.glProg=new l.default(this.el,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            attribute vec4 a_color;\n\n            uniform mat4 u_worldMatrix;\n            uniform mat4 u_worldProjectionMatrix;\n\n            varying vec4 v_color;\n            varying vec3 v_normal;\n\n            void main() {\n              gl_Position = u_worldProjectionMatrix * a_position;\n              v_color = a_color;\n              v_normal = mat3(u_worldMatrix) * a_normal;\n            }\n        ","\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n                precision highp float;\n            #else\n                precision mediump float;\n            #endif\n            \n            uniform vec3 u_lightDirection;\n\n            varying vec4 v_color;\n            varying vec3 v_normal;\n\n            void main() {\n                vec3 normal = normalize(v_normal);\n                vec3 lightDirection = normalize(u_lightDirection);\n                \n                float light = dot(normal, -lightDirection);\n            \n                gl_FragColor = v_color;\n                gl_FragColor.rgb *= light;\n            }\n        ",["a_position","a_normal","a_color"],["u_worldMatrix","u_worldProjectionMatrix","u_lightDirection"]),this.glProg.gl.enable(this.glProg.gl.CULL_FACE),this.glProg.gl.cullFace(this.glProg.gl.BACK),this.glProg.gl.enable(this.glProg.gl.DEPTH_TEST),this.glVertexBuffer=this.glProg.createBuffer(),this.glIndexBuffer=this.glProg.createBuffer(),this.glDynamicVertexBuffer=this.glProg.createBuffer(),this.glDynamicIndexBuffer=this.glProg.createBuffer()}generateGrid(){this.grid=[];for(let t=0;t<this.gridWidth;++t){this.grid[t]=[];for(let e=0;e<this.gridHeight;++e)this.grid[t][e]=[],Math.random()<=this.population?this.grid[t][e].push(new s.House(this.gridSize,(0,s.calcHeight)(t,e,this.gridWidth,this.gridHeight,this.heightFactor,this.maxHeight,this.minHeight),s.PALLETS[Math.trunc(Math.random()*s.PALLETS.length)])):Math.random()<=this.vegetation&&this.grid[t][e].push(new s.Tree(this.gridSize))}const t=new Set,e=new Set;for(let e=0;e<this.roads;e+=2){const e=Math.trunc(Math.random()*this.gridWidth);for(let i=0;i<this.gridWidth;++i){const r=(e+i)%this.gridWidth;if(!(t.has(r)||t.has(r-1)||t.has(r+1))){t.add(r);break}}}for(let t=1;t<this.roads;t+=2){const t=Math.trunc(Math.random()*this.gridHeight);for(let i=0;i<this.gridHeight;++i){const r=(t+i)%this.gridHeight;if(!(e.has(r)||e.has(r-1)||e.has(r+1))){e.add(r);break}}}for(const t of e)for(let e=0;e<this.gridWidth;++e)this.grid[e][t]=[new s.Road(this.gridSize,s.RoadDirection.X)];for(const e of t)for(let t=0;t<this.gridHeight;++t)this.grid[e][t]=[new s.Road(this.gridSize,s.RoadDirection.Y)];for(const i of e)for(const e of t)this.grid[e][i]=[new s.Road(this.gridSize,s.RoadDirection.LINK)]}static reserveBuffers(t,e,i){t.reserveAndClean(3*i*(3*Float32Array.BYTES_PER_ELEMENT+3*Float32Array.BYTES_PER_ELEMENT+4)),e.reserveAndClean(3*i*Uint16Array.BYTES_PER_ELEMENT)}static bindArrayBuffer(t,e,i){const r=t.gl,n=Float32Array.BYTES_PER_ELEMENT;t.arrayBuffer(e,6*n+4,{a_position:{elems:3,elType:r.FLOAT,normalized:!1,offsetBytes:0},a_normal:{elems:3,elType:r.FLOAT,normalized:!1,offsetBytes:3*n},a_color:{elems:4,elType:r.UNSIGNED_BYTE,normalized:!0,offsetBytes:6*n}},null==i?void 0:i.sliceFloat32())}static bindIndexBuffer(t,e,i){t.indexBuffer(e,null==i?void 0:i.sliceUint16())}static writeBuffers(t,e,i,r,n){i.forEach(((i,s)=>i.forEach(((i,o)=>{const a=t.bytes;if(i.forEach((i=>n(i,t,e))),t.bytes>a){const e=t.sliceFloat32(a);for(let t=0;t<e.length;t+=7)e[t+0]+=r*s,e[t+1]+=r*o}}))))}fillStaticBuffers(){const t=this.grid.flatMap((t=>t)).flatMap((t=>t)).reduce(((t,e)=>t+e.getTriangleCount()),0);c.reserveBuffers(this.vertexBuffer,this.indexBuffer,t),c.writeBuffers(this.vertexBuffer,this.indexBuffer,this.grid,this.gridSize,((t,e,i)=>t.writeObject(e,i))),this.glProg.useProgram(),c.bindArrayBuffer(this.glProg,this.glVertexBuffer,this.vertexBuffer),c.bindIndexBuffer(this.glProg,this.glIndexBuffer,this.indexBuffer),this.staticTriangles=this.indexBuffer.bytes/2}drawNextFrame(){if(this.paused)return;window.requestAnimationFrame(this.drawNextFrame.bind(this));const t=this.glProg.gl;if(!(0,n.isVisible)(t))return;(0,n.resizeContext)(t),t.clearColor(this.bgColor.r,this.bgColor.g,this.bgColor.b,this.bgColor.a),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT);let e=0;this.grid.forEach((t=>t.forEach((t=>t.forEach((t=>{t.frameUpdate(),e+=t.getDynamicTriangleCount()})))))),c.reserveBuffers(this.vertexBuffer,this.indexBuffer,e),c.writeBuffers(this.vertexBuffer,this.indexBuffer,this.grid,this.gridSize,((t,e,i)=>t.writeDynamicObject(e,i))),this.glProg.useProgram();{this.cameraRotation-=this.rotationSpeed,this.cameraRotation<2*-Math.PI&&(this.cameraRotation=0);const t=this.gridWidth*this.gridSize/2,e=this.gridHeight*this.gridSize/2,i=Math.max(this.gridWidth,this.gridHeight)*this.gridSize,r=i/2,n=Math.sin(this.cameraRotation)*i+r,s=-Math.cos(this.cameraRotation)*i+r,a=r,h=o.default.LookAt(n,s,a,t,e,0,0,0,1),l=o.default.Ortho(-this.glProg.width,this.glProg.width,-this.glProg.height,this.glProg.height,-1e4,1e4);l.multiply(h),this.glProg.uniformMatrix("u_worldMatrix",h.data),this.glProg.uniformMatrix("u_worldProjectionMatrix",l.data),this.glProg.uniformVector("u_lightDirection",-.2,-.5,-1)}c.bindArrayBuffer(this.glProg,this.glVertexBuffer),c.bindIndexBuffer(this.glProg,this.glIndexBuffer),this.glProg.drawElements(t.TRIANGLES,this.staticTriangles,t.UNSIGNED_SHORT),c.bindArrayBuffer(this.glProg,this.glDynamicVertexBuffer,this.vertexBuffer),c.bindIndexBuffer(this.glProg,this.glDynamicIndexBuffer,this.indexBuffer),this.glProg.drawElements(t.TRIANGLES,this.indexBuffer.bytes/2,t.UNSIGNED_SHORT)}detach(){this.paused=!0,this.glProg.deleteBuffer(this.glVertexBuffer),this.glProg.deleteBuffer(this.glIndexBuffer),this.glProg.deleteBuffer(this.glDynamicVertexBuffer),this.glProg.deleteBuffer(this.glDynamicIndexBuffer),this.glProg.destroyProgram()}}e.default=c},325:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.calcHeight=e.PALLETS=e.Color=e.Road=e.RoadDirection=e.Tree=e.Antenna=e.Windows=e.Roof=e.House=e.DebugFloor=e.TownObject=void 0;const r=i(109);class n{getTriangleCount(){return 0}writeObject(t,e){}getDynamicTriangleCount(){return 0}writeDynamicObject(t,e){}frameUpdate(){}}var s,o;e.TownObject=n,e.DebugFloor=class extends n{constructor(t){super(),this.width=t,this.color=d.RandomColor()}getTriangleCount(){return 2}writeObject(t,e){f(t,e,(0,r.XYPlane)(this.width,this.width),this.color)}},e.House=class extends n{constructor(t,e,i){super(),this.height=e,this.color=i,this.width=t/(3*Math.random()+1),this.depth=t/(3*Math.random()+1),this.x=(t-this.width)/(5*Math.random()+1),this.y=(t-this.depth)/(5*Math.random()+1),this.roof=Math.random()>.33?new a(i,this.x,this.y,e,this.width,this.depth):void 0,this.windows=new h(i,this.x,this.y,this.width,this.height,this.depth),this.antenna=Math.random()<=.3?new l(this.x,this.y,this.height,this.width,this.depth):void 0}frameUpdate(){var t,e;super.frameUpdate(),null===(t=this.roof)||void 0===t||t.frameUpdate(),this.windows.frameUpdate(),null===(e=this.antenna)||void 0===e||e.frameUpdate()}getDynamicTriangleCount(){var t,e;return super.getDynamicTriangleCount()+((null===(t=this.roof)||void 0===t?void 0:t.getDynamicTriangleCount())||0)+this.windows.getDynamicTriangleCount()+((null===(e=this.antenna)||void 0===e?void 0:e.getDynamicTriangleCount())||0)}writeDynamicObject(t,e){var i,r;super.writeDynamicObject(t,e),null===(i=this.roof)||void 0===i||i.writeDynamicObject(t,e),this.windows.writeDynamicObject(t,e),null===(r=this.antenna)||void 0===r||r.writeDynamicObject(t,e)}getTriangleCount(){var t,e;return 12+((null===(t=this.roof)||void 0===t?void 0:t.getTriangleCount())||0)+this.windows.getTriangleCount()+((null===(e=this.antenna)||void 0===e?void 0:e.getTriangleCount())||0)}writeObject(t,e){var i,n;const s=(0,r.Cuboid)(this.width,this.depth,this.height);(0,r.translate)(s,this.x,this.y,0),f(t,e,s,this.color),null===(i=this.roof)||void 0===i||i.writeObject(t,e),this.windows.writeObject(t,e),null===(n=this.antenna)||void 0===n||n.writeObject(t,e)}},function(t){t[t.X=0]="X",t[t.Y=1]="Y"}(s||(s={}));class a extends n{constructor(t,e,i,r,n,o){super(),this.houseColor=t,this.x=e,this.y=i,this.z=r,this.w=n,this.d=o,this.type=Math.random()<=.5?s.X:s.Y,this.roofColor=new d(70,70,70,t.a)}getTriangleCount(){return 6}writeObject(t,e){if(this.type===s.X){const i=(0,r.Plane45deg)(this.w,this.d/2,a.ROOF_HEIGHT,!0,r.PlaneRotate.X);(0,r.translate)(i,this.x,this.y,this.z),f(t,e,i,this.roofColor);const n=(0,r.Plane45deg)(this.w,this.d/2,a.ROOF_HEIGHT,!1,r.PlaneRotate.X);(0,r.translate)(n,this.x,this.y+this.d/2,this.z),f(t,e,n,this.roofColor);const s=(0,r.Triangle)(0,this.d/2,a.ROOF_HEIGHT,0,this.d,0,-1,0,0);(0,r.translate)(s,this.x,this.y,this.z),f(t,e,s,this.houseColor);const o=(0,r.Triangle)(0,this.d,0,0,this.d/2,a.ROOF_HEIGHT,1,0,0);(0,r.translate)(o,this.x+this.w,this.y,this.z),f(t,e,o,this.houseColor)}else if(this.type===s.Y){const i=(0,r.Plane45deg)(this.w/2,this.d,a.ROOF_HEIGHT,!0,r.PlaneRotate.Y);(0,r.translate)(i,this.x,this.y,this.z),f(t,e,i,this.roofColor);const n=(0,r.Plane45deg)(this.w/2,this.d,a.ROOF_HEIGHT,!1,r.PlaneRotate.Y);(0,r.translate)(n,this.x+this.w/2,this.y,this.z),f(t,e,n,this.roofColor);const s=(0,r.Triangle)(this.w,0,0,this.w/2,0,a.ROOF_HEIGHT,0,-1,0);(0,r.translate)(s,this.x,this.y,this.z),f(t,e,s,this.houseColor);const o=(0,r.Triangle)(this.w/2,0,a.ROOF_HEIGHT,this.w,0,0,0,1,0);(0,r.translate)(o,this.x,this.y+this.d,this.z),f(t,e,o,this.houseColor)}}}e.Roof=a,a.ROOF_HEIGHT=20;class h extends n{constructor(t,e,i,r,n,s){if(super(),this.color=t,this.x=e,this.y=i,this.width=r,this.height=n,this.depth=s,this.activeWindowsX=new Map,this.activeWindowsY=new Map,this.color=new d(this.color.r-10,this.color.g-10,this.color.b-10,this.color.a),this.windowsZ=Math.trunc(n/(h.windowHeight+2*h.offset)),this.windowsY=Math.trunc(s/(h.windowWidth+2*h.offset)),this.windowsX=Math.trunc(r/(h.windowWidth+2*h.offset)),this.windowsZ>0){if(this.windowsY>0)for(let t=0;t<h.activeWindowsOnOneWall;++t){const t=Math.trunc(Math.random()*this.windowsY),e=Math.trunc(Math.random()*this.windowsZ);this.activeWindowsY.set(1e3*e+t,{delayFrames:60*Math.random()*5+60,currentFrame:0,duration:60*Math.random()*2+60})}if(this.windowsX>0)for(let t=0;t<h.activeWindowsOnOneWall;++t){const t=Math.trunc(Math.random()*this.windowsX),e=Math.trunc(Math.random()*this.windowsZ);this.activeWindowsX.set(1e3*e+t,{delayFrames:60*Math.random()*5+60,currentFrame:0,duration:60*Math.random()*2+60})}}}getDynamicTriangleCount(){return 2*(this.windowsY+this.windowsX)*this.windowsZ*2}writeDynamicObject(t,e){const i=h.windowHeight+2*h.offset,n=(this.height-this.windowsZ*i)/2,s=h.windowWidth+2*h.offset,o=(this.depth-this.windowsY*s)/2,a=(this.width-this.windowsX*s)/2;{const a=this.x;for(let l=0;l<this.windowsZ;++l){const c=l*i+h.offset+n;for(let i=0;i<this.windowsY;++i){const n=i*s+h.offset+this.y+o,u=this.animInfo(void 0,i,l),d=u?h.calcColor(this.color,u):this.color,g=(0,r.YZPlane)(h.windowWidth,h.windowHeight);(0,r.translate)(g,a-1,n,c),f(t,e,g,d);const m=(0,r.YZPlane)(h.windowWidth,h.windowHeight);(0,r.rotateZ180)(m),(0,r.translate)(m,a+this.width+1,n,c),f(t,e,m,d)}}}{const o=this.y;for(let l=0;l<this.windowsZ;++l){const c=l*i+h.offset+n;for(let i=0;i<this.windowsX;++i){const n=i*s+h.offset+this.x+a,u=this.animInfo(i,void 0,l),d=u?h.calcColor(this.color,u):this.color,g=(0,r.XZPlane)(h.windowWidth,h.windowHeight);(0,r.translate)(g,n,o-1,c),f(t,e,g,d);const m=(0,r.XZPlane)(h.windowWidth,h.windowHeight);(0,r.rotateZ180)(m),(0,r.translate)(m,n,o+this.depth+1,c),f(t,e,m,d)}}}}animInfo(t,e,i){return void 0!==t?this.activeWindowsX.get(1e3*i+t):void 0!==e?this.activeWindowsY.get(1e3*i+e):void 0}frameUpdate(){super.frameUpdate(),this.activeWindowsX.forEach((t=>h.updateAnim(t))),this.activeWindowsY.forEach((t=>h.updateAnim(t)))}static updateAnim(t){t.currentFrame++,t.currentFrame>=t.delayFrames+t.duration+t.delayFrames+t.duration&&(t.currentFrame=0)}static calcColor(t,{delayFrames:e,currentFrame:i,duration:r}){if(i<=e)return t;if((i-=e)<=r){const e=170/r*i;return new d(t.r+e,t.g+e,t.b+e,t.a)}if((i-=r)<=e){const e=170;return new d(t.r+e,t.g+e,t.b+e,t.a)}if((i-=e)<=r){const e=170-170/r*i;return new d(t.r+e,t.g+e,t.b+e,t.a)}return t}}e.Windows=h,h.windowWidth=20,h.windowHeight=20,h.offset=5,h.activeWindowsOnOneWall=4;class l extends n{constructor(t,e,i,r,n){super(),this.z=i,this.color=new d(40,40,40,255);const s=Math.random();s<=.25?(this.x=t+l.OFFSET,this.y=e+l.OFFSET):s<=.5?(this.x=t+r-l.OFFSET,this.y=e+l.OFFSET):s<=.75?(this.x=t+l.OFFSET,this.y=e+n-l.OFFSET):(this.x=t+r-l.OFFSET,this.y=e+n-l.OFFSET),this.direction=Math.random()<.5,this.lines=Math.round(3*Math.random()+1)}getTriangleCount(){return 4*(this.lines+1)}writeObject(t,e){const i=this.x,n=this.y,s=this.direction?r.XZPlane:r.YZPlane,o=this.direction?l.WIDTH/2:0,a=this.direction?0:l.WIDTH/2,h=s(l.LINE_WIDTH,l.HEIGHT);(0,r.translate)(h,i,n,this.z),f(t,e,h,this.color);const c=s(l.LINE_WIDTH,l.HEIGHT);(0,r.rotateZ180)(c),(0,r.translate)(c,i,n,this.z),f(t,e,c,this.color);for(let h=0;h<this.lines;++h){const c=this.z+l.HEIGHT-l.HEIGHT/2/this.lines*(h+1),u=s(l.WIDTH,l.LINE_WIDTH);(0,r.translate)(u,i-o,n-a,c),f(t,e,u,this.color);const d=s(l.WIDTH,l.LINE_WIDTH);(0,r.rotateZ180)(d),(0,r.translate)(d,i-o,n-a,c),f(t,e,d,this.color)}}}e.Antenna=l,l.WIDTH=15,l.HEIGHT=35,l.LINE_WIDTH=2,l.OFFSET=6;class c extends n{constructor(t){super(),this.ROOT_COLOR=new d(112,94,88,255),this.LEAF_COLOR=new d(64,93,53,255),this.width=c.WIDTH+Math.trunc(40*Math.random()-20),this.height=c.HEIGHT+Math.trunc(80*Math.random()-40),this.x=(t-this.width)/(10*Math.random()+1),this.y=(t-this.width)/(10*Math.random()+1),this.leaf=Math.random()<.5?1:c.MAX_LEAF}getTriangleCount(){return 12+6*this.leaf}writeObject(t,e){const i=this.x,n=this.y,s=this.width,o=this.height,a=o/(c.MAX_LEAF+1),h=(0,r.Cuboid)(c.ROOT_WIDTH,c.ROOT_WIDTH,a);(0,r.translate)(h,i+s/2-c.ROOT_WIDTH/2,n+s/2-c.ROOT_WIDTH/2,0),f(t,e,h,this.ROOT_COLOR);const l=(o-a)/this.leaf;for(let h=1;h<=this.leaf;++h){const c=Math.min(s/h*1.7,s),u=o-a-l*(h-1),d=(0,r.Pyramid)(c,c,u);(0,r.translate)(d,i+(s-c)/2,n+(s-c)/2,o-u),f(t,e,d,this.LEAF_COLOR)}}}e.Tree=c,c.ROOT_WIDTH=5,c.WIDTH=60,c.HEIGHT=200,c.MAX_LEAF=3,function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.LINK=2]="LINK"}(o=e.RoadDirection||(e.RoadDirection={}));class u extends n{constructor(t,e){super(),this.gridSize=t,this.direction=e,this.BORDER_COLOR=new d(175,157,151,255),this.ROAD_COLOR=new d(163,145,139,255),this.LINE_COLOR=new d(255,255,255,255)}getTriangleCount(){return this.direction!=o.LINK?6+u.LINES:6}writeObject(t,e){if(this.direction===o.X){const i=u.OFFSET,n=(this.gridSize-2*i)/6,s=(0,r.XYPlane)(this.gridSize,this.gridSize-2*i-2*n);(0,r.translate)(s,0,i+n,0),f(t,e,s,this.ROAD_COLOR);const o=(0,r.XYPlane)(this.gridSize,n);(0,r.translate)(o,0,i,0),f(t,e,o,this.BORDER_COLOR),(0,r.translate)(o,0,-i+this.gridSize-i-n,0),f(t,e,o,this.BORDER_COLOR);const a=this.gridSize/(2*u.LINES),h=(0,r.Triangle)(a,2,0,0,4,0,0,0,1);(0,r.translate)(h,a/2,this.gridSize/2,1);for(let i=0;i<u.LINES;++i)f(t,e,h,this.LINE_COLOR),(0,r.translate)(h,2*a,0,0)}else if(this.direction===o.Y){const i=u.OFFSET,n=(this.gridSize-2*i)/6,s=(0,r.XYPlane)(this.gridSize-2*i-2*n,this.gridSize);(0,r.translate)(s,i+n,0,0),f(t,e,s,this.ROAD_COLOR);const o=(0,r.XYPlane)(n,this.gridSize);(0,r.translate)(o,i,0,0),f(t,e,o,this.BORDER_COLOR),(0,r.translate)(o,-i+this.gridSize-i-n,0,0),f(t,e,o,this.BORDER_COLOR);const a=this.gridSize/(2*u.LINES),h=(0,r.Triangle)(4,0,0,2,a,0,0,0,1);(0,r.translate)(h,this.gridSize/2,a/2,1);for(let i=0;i<u.LINES;++i)f(t,e,h,this.LINE_COLOR),(0,r.translate)(h,0,2*a,0)}else if(this.direction===o.LINK){f(t,e,(0,r.XYPlane)(this.gridSize,this.gridSize),this.ROAD_COLOR);const i=u.OFFSET,n=(this.gridSize-2*i)/6+i,s=(0,r.Triangle)(n,0,0,0,n,0,0,0,1);(0,r.translate)(s,0,0,1),f(t,e,s,this.BORDER_COLOR);const o=(0,r.Triangle)(n,0,0,n,n,0,0,0,1);(0,r.translate)(o,this.gridSize-n,0,1),f(t,e,o,this.BORDER_COLOR);const a=(0,r.Triangle)(n,n,0,0,n,0,0,0,1);(0,r.translate)(a,0,this.gridSize-n,1),f(t,e,a,this.BORDER_COLOR);const h=(0,r.Triangle)(-n,0,0,0,-n,0,0,0,1);(0,r.translate)(h,this.gridSize,this.gridSize,1),f(t,e,h,this.BORDER_COLOR)}}}e.Road=u,u.OFFSET=20,u.LINES=4;class d{constructor(t,e,i,r){this.r=t,this.g=e,this.b=i,this.a=r,this.r=t<0?0:t>255?255:t,this.g=e<0?0:e>255?255:e,this.b=i<0?0:i>255?255:i}static RandomColor(){return new d(255*Math.random(),255*Math.random(),255*Math.random(),255)}}function f(t,e,i,r){const n=e.nextIndex;for(let t=0;t<i.indexes.length;t+=3)e.write3Uint16(i.indexes[t+0]+n,i.indexes[t+1]+n,i.indexes[t+2]+n);for(let e=0;e<i.positions.length;e+=3){t.write3Float32(i.positions[e+0],i.positions[e+1],i.positions[e+2]);const n=3===i.normals.length?0:e;t.write3Float32(i.normals[n+0],i.normals[n+1],i.normals[n+2]),t.write4Uint8(r.r,r.g,r.b,r.a)}}e.Color=d,e.PALLETS=[new d(238,238,238,255),new d(85,85,85,255),new d(135,136,132,255),new d(236,236,215,255),new d(209,221,226,255),new d(145,149,152,255),new d(67,151,74,255),new d(235,198,1,255),new d(199,93,111,255),new d(231,151,82,255),new d(74,113,167,255),new d(217,170,142,255),new d(120,149,109,255),new d(165,105,104,255),new d(228,203,169,255),new d(235,193,148,255),new d(183,65,76,255),new d(233,84,68,255)],e.calcHeight=function(t,e,i,r,n,s,o){const a=Math.pow(Math.sin(Math.PI*((t+.5)/i))*Math.sin(Math.PI*((e+.5)/r)),n);return Math.max(Math.min(s,s*a),o)}}},e={};!function i(r){var n=e[r];if(void 0!==n)return n.exports;var s=e[r]={exports:{}};return t[r].call(s.exports,s,s.exports,i),s.exports}(607)})();