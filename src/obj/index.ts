import OBJ from "../WebGL/parsers/obj";
import {Material, parseMTL} from "../WebGL/parsers/mtl";
import WebGLProgramContext from "../WebGL/WebGLProgramContext";
import DataBuffer from "../WebGL/wrappers/DataBuffer";
import IndexBuffer from "../WebGL/wrappers/IndexBuffer";
import {resizeContext} from "../WebGL/WebGLUtil";
import Matrix4 from "../WebGL/Matrix4";

export async function loadObjFile(url: string): Promise<OBJ> {
    const response = await fetch(url);
    const text = await response.text();
    return OBJ.parse(text);
}

export async function loadMtlFile(url: string): Promise<Map<string, Material>> {
    const response = await fetch(url);
    const text = await response.text();
    return parseMTL(text);
}

export enum ProgType {
    DO_NOT_DRAW, POINTS, LINES, SIMPLE_LIGHT, SPECULAR_LIGHT
}

export default class ObjController {
    readonly el: HTMLCanvasElement;
    readonly obj: OBJ;
    readonly mtl: Map<string, Material>;

    progs = new Map<ProgType, WebGLProgramContext>();
    vertexBuffer = new DataBuffer(1);
    indexBuffer = new IndexBuffer(1);

    glVertexBuffer!: WebGLBuffer;
    glIndexBuffer!: WebGLBuffer;

    background: [number, number, number, number];
    prop: Map<string, ProgType>;
    objCoordRange: { min: [number, number, number], max: [number, number, number] };
    cameraRotation = 0
    rotationSpeed = Math.PI / 200

    paused = false;

    constructor(el: HTMLCanvasElement, obj: OBJ, mtl: Map<string, Material>,
                pointSize: number, backgroundColor: [number, number, number]) {
        obj.geometries.forEach(g => g.name = g.name || 'N/A');

        this.el = el;
        this.obj = obj;
        this.mtl = mtl;

        this.prop = new Map(this.obj.geometries.map(g => [g.name, ProgType.SIMPLE_LIGHT] as [string, ProgType]));
        this.background = [...backgroundColor, 1];
        this.objCoordRange = obj.getSize();

        this.initGLContext();
        this.compilePrograms(pointSize);
        this.fillBuffers();
        this.drawNextFrame();
    }

    private initGLContext() {
        const vs = 'void main() { gl_Position = vec4(0, 0, 0, 0); }';
        const fs = 'void main() { gl_FragColor = vec4(0, 0, 0, 0); }';
        const p = new WebGLProgramContext(this.el, vs, fs, [], []);

        const gl = p.gl;
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        this.glVertexBuffer = gl.createBuffer()!;
        this.glIndexBuffer = gl.createBuffer()!;
    }

    private compilePrograms(pointSize: number) {
        const vs = `
          attribute vec4 a_position;
          attribute vec3 a_normal;
        
          uniform mat4 u_worldMatrix;
          uniform mat4 u_worldProjectionMatrix;
          uniform vec3 u_viewWorldPosition; // camera
        
          varying vec3 v_normal;
          varying vec3 v_surfaceToView;
        
          void main() {
            gl_Position = u_worldProjectionMatrix * a_position;
            gl_PointSize = ${pointSize};
            v_normal = mat3(u_worldMatrix) * a_normal;
            // vector vertex->camera
            v_surfaceToView = u_viewWorldPosition - (u_worldMatrix * a_position).xyz;
          }
        `;
        const attributes = ['a_position', 'a_normal'];
        const uniforms = ['u_worldMatrix', 'u_worldProjectionMatrix', 'u_lightDirection', 'u_viewWorldPosition',
            'diffuse', 'ambient', 'u_ambientLight', 'emissive', 'specular', 'shininess', 'opacity'];
        {
            const fs = `
                #ifdef GL_FRAGMENT_PRECISION_HIGH
                    precision highp float;
                #else
                    precision mediump float;
                #endif
                
                varying vec3 v_normal;
                varying vec3 v_surfaceToView;
              
                // material color
                uniform vec3 diffuse;
                // uniform sampler2D diffuseMap;
                
                // ambient light (sky, sun, ...)
                uniform vec3 ambient;
                uniform vec3 u_ambientLight;
                
                // light, which is generated by material
                uniform vec3 emissive;
                
                // reflection light and its force
                uniform vec3 specular;
                // uniform sampler2D specularMap;
                uniform float shininess; // 1 - strong, 2 - smooth
                
                uniform float opacity;
                
                uniform vec3 u_lightDirection;
              
                void main () {
                  vec4 v_color = vec4(1, 1, 1, 1);
                  vec3 normal = normalize(v_normal);
              
                  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
                  
                  // vector between camera and light 
                  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);
                  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);
                  //vec4 specularMapColor = texture2D(specularMap, v_texcoord);
                  vec4 specularMapColor = vec4(1, 1, 1, 1);
                  vec3 effectiveSpecular = specular * specularMapColor.rgb;
              
                  float fakeLight = dot(u_lightDirection, normal) * .25;
                  //vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
                  vec4 diffuseMapColor = vec4(1, 1, 1, 1);
                  vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
                  float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;
              
                  gl_FragColor = vec4(
                      emissive +
                      ambient * u_ambientLight +
                      effectiveDiffuse * fakeLight +
                      effectiveSpecular * pow(specularLight, shininess),
                      effectiveOpacity);
                }
            `;
            this.progs.set(ProgType.SPECULAR_LIGHT, new WebGLProgramContext(this.el, vs, fs, attributes, uniforms));
        }
        {
            const fs = `
                #ifdef GL_FRAGMENT_PRECISION_HIGH
                    precision highp float;
                #else
                    precision mediump float;
                #endif
                
                varying vec3 v_normal;
                varying vec3 v_surfaceToView;
              
                uniform vec3 diffuse;
                uniform vec3 ambient;
                uniform vec3 u_ambientLight;
                uniform vec3 emissive;
                uniform vec3 specular;
                uniform float shininess;
                uniform float opacity;
                uniform vec3 u_lightDirection;
              
                void main () {
                  vec3 normal = normalize(v_normal);
                  vec3 lightDirection = normalize(u_lightDirection);
                  
                  float light = dot(normal, lightDirection);
                  
                  gl_FragColor = vec4(normalize(diffuse) * light, 1);
                }
            `;
            this.progs.set(ProgType.SIMPLE_LIGHT, new WebGLProgramContext(this.el, vs, fs, attributes, uniforms));
        }
        {
            const fs = `
                #ifdef GL_FRAGMENT_PRECISION_HIGH
                    precision highp float;
                #else
                    precision mediump float;
                #endif
                
                varying vec3 v_normal;
                varying vec3 v_surfaceToView;
              
                uniform vec3 diffuse;
                uniform vec3 ambient;
                uniform vec3 u_ambientLight;
                uniform vec3 emissive;
                uniform vec3 specular;
                uniform float shininess;
                uniform float opacity;
                uniform vec3 u_lightDirection;
              
                void main () {
                  gl_FragColor = vec4(normalize(diffuse), 1);
                }
            `;
            this.progs.set(ProgType.LINES, new WebGLProgramContext(this.el, vs, fs, attributes, uniforms));
        }
        {
            const fs = `
                #ifdef GL_FRAGMENT_PRECISION_HIGH
                    precision highp float;
                #else
                    precision mediump float;
                #endif
                
                varying vec3 v_normal;
                varying vec3 v_surfaceToView;
              
                uniform vec3 diffuse;
                uniform vec3 ambient;
                uniform vec3 u_ambientLight;
                uniform vec3 emissive;
                uniform vec3 specular;
                uniform float shininess;
                uniform float opacity;
                uniform vec3 u_lightDirection;
              
                void main () {
                  gl_FragColor = vec4(normalize(diffuse), 1);
                }
            `;
            this.progs.set(ProgType.POINTS, new WebGLProgramContext(this.el, vs, fs, attributes, uniforms));
        }
    }

    private fillBuffers() {
        // triangle = 3 vertexes * (xyz + normal)
        this.vertexBuffer.reserveAndClean(this.obj.getTriangleCount() * 3 * ((3 + 3) * Float32Array.BYTES_PER_ELEMENT));
        // triangle = 3 vertexes indexes
        this.indexBuffer.reserveAndClean(this.obj.getTriangleCount() * 3 * Uint16Array.BYTES_PER_ELEMENT);

        for (const g of this.obj.geometries) {
            for (const t of g.triangles) {
                const v1 = this.obj.getPositionOf(t[0]);
                const v2 = this.obj.getPositionOf(t[1]);
                const v3 = this.obj.getPositionOf(t[2]);

                const a = [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
                const b = [v1[0] - v3[0], v1[1] - v3[1], v1[2] - v3[2]];
                const normal = [
                    a[1] * b[2] - a[2] * b[1],
                    -a[0] * b[2] + a[2] * b[0],
                    a[0] * b[1] - a[1] * b[0],
                ] as [number, number, number];

                for (const v of [v1, v2, v3]) {
                    this.vertexBuffer.write3Float32(...v);
                    this.vertexBuffer.write3Float32(...normal);
                    this.indexBuffer.write1Uint16(this.indexBuffer.nextIndex);
                }
            }
        }

        const FLOAT_SIZE = Float32Array.BYTES_PER_ELEMENT;
        for (const p of this.progs.values()) {
            const gl = p.gl;
            p.arrayBuffer(this.glVertexBuffer, (3 + 3) * FLOAT_SIZE, {
                a_position: {elems: 3, elType: gl.FLOAT, normalized: false, offsetBytes: 0},
                a_normal: {elems: 3, elType: gl.FLOAT, normalized: false, offsetBytes: 3 * FLOAT_SIZE},
            }, this.vertexBuffer.sliceFloat32());
            p.indexBuffer(this.glIndexBuffer, this.indexBuffer.sliceUint16());
        }
    }

    private drawNextFrame() {
        if (this.paused) return;

        window.requestAnimationFrame(this.drawNextFrame.bind(this));

        const gl = this.progs.values().next().value.gl;
        resizeContext(gl);
        gl.clearColor(...this.background);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        {
            this.cameraRotation -= this.rotationSpeed;
            if (this.cameraRotation < -Math.PI * 2) {
                this.cameraRotation = 0;
            }

            // center of our coordinate system. We need to move object to [0, 0, 0]
            const center = [0, 0, 0] as [number, number, number];
            for (let i = 0; i < 3; ++i) {
                center[i] = this.objCoordRange.min[i] + (this.objCoordRange.max[i] - this.objCoordRange.min[i]) / 2
            }
            // since object is in [0, 0, 0] we can rotate object instead of camera
            const world = Matrix4.XRotate(Math.PI / 6).yRotate(this.cameraRotation).translate(-center[0], -center[1], -center[2]);

            const length = Math.sqrt(
                Math.pow(this.objCoordRange.max[0] - this.objCoordRange.min[0], 2) +
                Math.pow(this.objCoordRange.max[1] - this.objCoordRange.min[1], 2) +
                Math.pow(this.objCoordRange.max[2] - this.objCoordRange.min[2], 2)
            );
            const radius = length * 1.2;
            const zNear = radius / 1000;
            const zFar = radius * 3;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const cameraPos = [0, 0, radius] as [number, number, number];
            const worldProjectionMatrix = Matrix4.Perspective(60 * Math.PI / 180, aspect, zNear, zFar);
            worldProjectionMatrix.multiply(Matrix4.LookAt(cameraPos[0], cameraPos[1], cameraPos[2], 0, 0, 0, 0, 1, 0));
            worldProjectionMatrix.multiply(world);

            let firstIndex = 0;
            for (const g of this.obj.geometries) {
                const progType = this.prop.get(g.name!);
                if (progType === undefined || progType === ProgType.DO_NOT_DRAW) {
                    firstIndex += g.triangles.length * 3;
                    continue;
                }

                const prog = this.progs.get(progType)!;
                prog.useProgram();

                prog.uniformMatrix('u_worldMatrix', world.data);
                prog.uniformMatrix('u_worldProjectionMatrix', worldProjectionMatrix.data);
                prog.uniformVector('u_lightDirection', 1, 3, 5);
                prog.uniformVector('u_viewWorldPosition', ...cameraPos);

                const material = this.mtl.get(g.material || '');
                prog.uniformVector('diffuse', ...(material?.diffuse || [1, 1, 1]));
                prog.uniformVector('ambient', ...(material?.ambient || [0, 0, 0]));
                prog.uniformVector('u_ambientLight', 0.1, 0.1, 0.1);
                prog.uniformVector('emissive', ...(material?.emissive || [0, 0, 0]));
                prog.uniformVector('specular', ...(material?.specular || [1, 1, 1]));
                prog.uniformVector('shininess', material?.shininess || 400);
                prog.uniformVector('opacity', material?.opacity || 1);

                const indexes = g.triangles.length * 3;
                const primitive = progType === ProgType.POINTS
                    ? gl.POINTS
                    : (progType === ProgType.LINES ? gl.LINE_LOOP : gl.TRIANGLES);
                prog.drawElements(primitive, indexes, gl.UNSIGNED_SHORT, firstIndex * Uint16Array.BYTES_PER_ELEMENT);
                firstIndex += indexes;
            }
        }
    }

    public get objectNames() {
        return this.obj.geometries.map(g => g.name);
    }

    public setProperty(objName: string, p: ProgType) {
        this.prop.set(objName, p);
    }

    public set active(v: boolean) {
        this.paused = !v;
        if (!this.paused) {
            this.drawNextFrame();
        }
    }
}
